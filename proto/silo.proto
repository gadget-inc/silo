syntax = "proto3";

package silo.v1;

// Core job messages
message JsonValueBytes {
  bytes data = 1; // raw JSON bytes
}

message RetryPolicy {
  uint32 retry_count = 1;
  int64 initial_interval_ms = 2;
  int64 max_interval_ms = 3;
  bool randomize_interval = 4;
  double backoff_factor = 5;
}

// Per-job concurrency limit declaration
message ConcurrencyLimit {
  string key = 1;             // grouping key; jobs with same key share a limit
  uint32 max_concurrency = 2; // maximum concurrent running jobs for this key
}

// Floating concurrency limit - max concurrency is dynamic and refreshed by workers
message FloatingConcurrencyLimit {
  string key = 1;                        // grouping key; jobs with same key share a limit
  uint32 default_max_concurrency = 2;    // initial max concurrency value used until first refresh
  int64 refresh_interval_ms = 3;         // how often to refresh the max concurrency value
  map<string, string> metadata = 4;      // arbitrary key/value metadata passed to workers during refresh
}

// Gubernator rate limiting algorithm
enum GubernatorAlgorithm {
  GUBERNATOR_ALGORITHM_TOKEN_BUCKET = 0;  // Token bucket algorithm
  GUBERNATOR_ALGORITHM_LEAKY_BUCKET = 1;  // Leaky bucket algorithm
}

// Gubernator behavior flags (can be combined via bitwise OR)
enum GubernatorBehavior {
  GUBERNATOR_BEHAVIOR_BATCHING = 0;           // Default: batch requests to peers
  GUBERNATOR_BEHAVIOR_NO_BATCHING = 1;        // Disable batching
  GUBERNATOR_BEHAVIOR_GLOBAL = 2;             // Global rate limit across all peers
  GUBERNATOR_BEHAVIOR_DURATION_IS_GREGORIAN = 4; // Duration resets on calendar boundaries
  GUBERNATOR_BEHAVIOR_RESET_REMAINING = 8;    // Reset the rate limit on this request
  GUBERNATOR_BEHAVIOR_DRAIN_OVER_LIMIT = 16;  // Drain remaining counter on over limit
}

// Retry policy specifically for rate limit check retries (when rate limit is exceeded)
message RateLimitRetryPolicy {
  int64 initial_backoff_ms = 1;  // Initial backoff time when rate limited
  int64 max_backoff_ms = 2;      // Maximum backoff time
  double backoff_multiplier = 3; // Multiplier for exponential backoff (default 2.0)
  uint32 max_retries = 4;        // Maximum number of retries (0 = infinite until reset_time)
}

// Gubernator-based rate limit declaration
message GubernatorRateLimit {
  string name = 1;              // Name identifying this rate limit (for debugging/metrics)
  string unique_key = 2;        // Unique key for this specific rate limit instance
  int64 limit = 3;              // Maximum requests allowed in the duration
  int64 duration_ms = 4;        // Duration window in milliseconds
  int32 hits = 5;               // Number of hits to consume (usually 1)
  GubernatorAlgorithm algorithm = 6;  // Rate limiting algorithm
  int32 behavior = 7;           // Behavior flags (bitwise OR of GubernatorBehavior)
  RateLimitRetryPolicy retry_policy = 8; // How to retry when rate limited
}

// A single limit that can be either a concurrency limit, rate limit, or floating concurrency limit
message Limit {
  oneof limit {
    ConcurrencyLimit concurrency = 1;
    GubernatorRateLimit rate_limit = 2;
    FloatingConcurrencyLimit floating_concurrency = 3;
  }
}

message EnqueueRequest {
  uint32 shard = 1; // shard id
  string id = 2; // optional
  uint32 priority = 3; // 0..99, 0 highest
  int64 start_at_ms = 4; // epoch ms
  optional RetryPolicy retry_policy = 5; // optional
  JsonValueBytes payload = 6; // JSON
  repeated Limit limits = 7; // ordered list of limits to check before execution
  optional string tenant = 8; // optional tenant id when tenancy is enabled
  map<string, string> metadata = 9; // arbitrary key/value metadata stored with the job
}

message EnqueueResponse {
  string id = 1;
}

message GetJobRequest { uint32 shard = 1; string id = 2; optional string tenant = 3; }
message GetJobResponse {
  string id = 1;
  uint32 priority = 2;
  int64 enqueue_time_ms = 3;
  JsonValueBytes payload = 4;
  optional RetryPolicy retry_policy = 5; // presence indicates some policy
  repeated Limit limits = 6; // declared limits
  map<string, string> metadata = 7; // arbitrary key/value metadata stored with the job
}

message DeleteJobRequest { uint32 shard = 1; string id = 2; optional string tenant = 3; }
message DeleteJobResponse {}

message CancelJobRequest { uint32 shard = 1; string id = 2; optional string tenant = 3; }
message CancelJobResponse {}

// Lease tasks for processing from this server.
// By default, leases from all shards this server owns (fair distribution).
// If shard is specified, filters to only that shard.
message LeaseTasksRequest { 
  optional uint32 shard = 1;  // optional filter - if set, only lease from this shard
  string worker_id = 2; 
  uint32 max_tasks = 3; 
}
message Task {
  string id = 1;              // task id
  string job_id = 2;
  uint32 attempt_number = 3;
  int64 lease_ms = 4;         // how long to heartbeat in ms
  JsonValueBytes payload = 5; // job payload for convenience
  uint32 priority = 6;
  uint32 shard = 7;           // which shard this task came from (for reporting outcomes)
}

// Task for refreshing a floating concurrency limit - workers compute new max concurrency
message RefreshFloatingLimitTask {
  string id = 1;                          // task id
  string queue_key = 2;                   // the floating limit queue key
  uint32 current_max_concurrency = 3;     // the current max concurrency value
  int64 last_refreshed_at_ms = 4;         // when the value was last refreshed
  map<string, string> metadata = 5;       // opaque metadata from the limit definition
  int64 lease_ms = 6;                     // how long to heartbeat in ms
}

message LeaseTasksResponse { 
  repeated Task tasks = 1;
  repeated RefreshFloatingLimitTask refresh_tasks = 2;  // floating limit refresh tasks
}

// Report the outcome of a job attempt task from a worker back to the server
message ReportOutcomeRequest {
  uint32 shard = 1;
  string task_id = 2;
  optional string tenant = 5;
  oneof outcome {
    JsonValueBytes success = 3;
    Failure failure = 4;
    Cancelled cancelled = 6; // Worker acknowledges cancellation
  }
}
message Failure { string code = 1; bytes data = 2; }
message Cancelled {} // Empty marker for cancelled outcome
message ReportOutcomeResponse {}

// Report the outcome of a floating limit refresh task from a worker back to the server
message ReportRefreshOutcomeRequest {
  uint32 shard = 1;
  string task_id = 2;
  optional string tenant = 3;
  oneof outcome {
    RefreshSuccess success = 4;
    RefreshFailure failure = 5;
  }
}

message RefreshSuccess {
  uint32 new_max_concurrency = 1;  // the new max concurrency value computed by the worker
}

message RefreshFailure {
  string code = 1;    // error code
  string message = 2; // error message
}

message ReportRefreshOutcomeResponse {}

message HeartbeatRequest { 
  uint32 shard = 1; 
  string worker_id = 2; 
  string task_id = 3; 
  optional string tenant = 4;
}
message HeartbeatResponse {
  // True if the job has been cancelled. Worker should stop work and report Cancelled outcome.
  bool cancelled = 1;
  // Timestamp (epoch ms) when cancellation was requested, if cancelled
  optional int64 cancelled_at_ms = 2;
}

// Execute SQL query against shard data
message QueryRequest { 
  uint32 shard = 1; 
  string sql = 2; 
  optional string tenant = 3; 
}

// Column metadata for the result schema
message ColumnInfo {
  string name = 1;
  string data_type = 2; // Arrow/DataFusion type as string (e.g. "Utf8", "Int64", "UInt8")
}

// Query result row as JSON object
message QueryResponse {
  repeated ColumnInfo columns = 1; // Schema information
  repeated JsonValueBytes rows = 2; // Each row is a JSON object
  int32 row_count = 3; // Number of rows returned
}

// Cluster topology information for client-side routing
message GetClusterInfoRequest {}

message ShardOwner {
  uint32 shard_id = 1;
  string grpc_addr = 2;  // The gRPC address of the server owning this shard
  string node_id = 3;    // The node ID of the owner
}

message GetClusterInfoResponse {
  uint32 num_shards = 1;                    // Total number of shards in the cluster
  repeated ShardOwner shard_owners = 2;     // Mapping of shards to their owners
  string this_node_id = 3;                  // The node ID of the server responding
  string this_grpc_addr = 4;                // The gRPC address of the server responding
}

// Admin request to reset all shards (dev mode only)
// This clears all data from all shards owned by this server.
// WARNING: This is a destructive operation intended only for testing.
message ResetShardsRequest {}
message ResetShardsResponse {
  uint32 shards_reset = 1;  // Number of shards that were reset
}

service Silo {
  // Get cluster topology for client-side routing
  rpc GetClusterInfo(GetClusterInfoRequest) returns (GetClusterInfoResponse);
  
  rpc Enqueue(EnqueueRequest) returns (EnqueueResponse);
  rpc GetJob(GetJobRequest) returns (GetJobResponse);
  rpc DeleteJob(DeleteJobRequest) returns (DeleteJobResponse);
  rpc CancelJob(CancelJobRequest) returns (CancelJobResponse);
  rpc LeaseTasks(LeaseTasksRequest) returns (LeaseTasksResponse);
  rpc ReportOutcome(ReportOutcomeRequest) returns (ReportOutcomeResponse);
  rpc ReportRefreshOutcome(ReportRefreshOutcomeRequest) returns (ReportRefreshOutcomeResponse);
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);
  rpc Query(QueryRequest) returns (QueryResponse);
  
  // Admin: Reset all shards owned by this server (dev mode only)
  // Clears all data - jobs, tasks, queues, etc.
  rpc ResetShards(ResetShardsRequest) returns (ResetShardsResponse);
}


