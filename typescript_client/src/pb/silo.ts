// @generated by protobuf-ts 2.11.1 with parameter long_type_bigint,generate_dependencies
// @generated from protobuf file "silo.proto" (package "silo.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Core job messages
 *
 * @generated from protobuf message silo.v1.JsonValueBytes
 */
export interface JsonValueBytes {
    /**
     * @generated from protobuf field: bytes data = 1
     */
    data: Uint8Array; // raw JSON bytes
}
/**
 * @generated from protobuf message silo.v1.RetryPolicy
 */
export interface RetryPolicy {
    /**
     * @generated from protobuf field: uint32 retry_count = 1
     */
    retryCount: number;
    /**
     * @generated from protobuf field: int64 initial_interval_ms = 2
     */
    initialIntervalMs: bigint;
    /**
     * @generated from protobuf field: int64 max_interval_ms = 3
     */
    maxIntervalMs: bigint;
    /**
     * @generated from protobuf field: bool randomize_interval = 4
     */
    randomizeInterval: boolean;
    /**
     * @generated from protobuf field: double backoff_factor = 5
     */
    backoffFactor: number;
}
/**
 * Per-job concurrency limit declaration
 *
 * @generated from protobuf message silo.v1.ConcurrencyLimit
 */
export interface ConcurrencyLimit {
    /**
     * @generated from protobuf field: string key = 1
     */
    key: string; // grouping key; jobs with same key share a limit
    /**
     * @generated from protobuf field: uint32 max_concurrency = 2
     */
    maxConcurrency: number; // maximum concurrent running jobs for this key
}
/**
 * Floating concurrency limit - max concurrency is dynamic and refreshed by workers
 *
 * @generated from protobuf message silo.v1.FloatingConcurrencyLimit
 */
export interface FloatingConcurrencyLimit {
    /**
     * @generated from protobuf field: string key = 1
     */
    key: string; // grouping key; jobs with same key share a limit
    /**
     * @generated from protobuf field: uint32 default_max_concurrency = 2
     */
    defaultMaxConcurrency: number; // initial max concurrency value used until first refresh
    /**
     * @generated from protobuf field: int64 refresh_interval_ms = 3
     */
    refreshIntervalMs: bigint; // how often to refresh the max concurrency value
    /**
     * @generated from protobuf field: map<string, string> metadata = 4
     */
    metadata: {
        [key: string]: string;
    }; // arbitrary key/value metadata passed to workers during refresh
}
/**
 * Retry policy specifically for rate limit check retries (when rate limit is exceeded)
 *
 * @generated from protobuf message silo.v1.RateLimitRetryPolicy
 */
export interface RateLimitRetryPolicy {
    /**
     * @generated from protobuf field: int64 initial_backoff_ms = 1
     */
    initialBackoffMs: bigint; // Initial backoff time when rate limited
    /**
     * @generated from protobuf field: int64 max_backoff_ms = 2
     */
    maxBackoffMs: bigint; // Maximum backoff time
    /**
     * @generated from protobuf field: double backoff_multiplier = 3
     */
    backoffMultiplier: number; // Multiplier for exponential backoff (default 2.0)
    /**
     * @generated from protobuf field: uint32 max_retries = 4
     */
    maxRetries: number; // Maximum number of retries (0 = infinite until reset_time)
}
/**
 * Gubernator-based rate limit declaration
 *
 * @generated from protobuf message silo.v1.GubernatorRateLimit
 */
export interface GubernatorRateLimit {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string; // Name identifying this rate limit (for debugging/metrics)
    /**
     * @generated from protobuf field: string unique_key = 2
     */
    uniqueKey: string; // Unique key for this specific rate limit instance
    /**
     * @generated from protobuf field: int64 limit = 3
     */
    limit: bigint; // Maximum requests allowed in the duration
    /**
     * @generated from protobuf field: int64 duration_ms = 4
     */
    durationMs: bigint; // Duration window in milliseconds
    /**
     * @generated from protobuf field: int32 hits = 5
     */
    hits: number; // Number of hits to consume (usually 1)
    /**
     * @generated from protobuf field: silo.v1.GubernatorAlgorithm algorithm = 6
     */
    algorithm: GubernatorAlgorithm; // Rate limiting algorithm
    /**
     * @generated from protobuf field: int32 behavior = 7
     */
    behavior: number; // Behavior flags (bitwise OR of GubernatorBehavior)
    /**
     * @generated from protobuf field: silo.v1.RateLimitRetryPolicy retry_policy = 8
     */
    retryPolicy?: RateLimitRetryPolicy; // How to retry when rate limited
}
/**
 * A single limit that can be either a concurrency limit, rate limit, or floating concurrency limit
 *
 * @generated from protobuf message silo.v1.Limit
 */
export interface Limit {
    /**
     * @generated from protobuf oneof: limit
     */
    limit: {
        oneofKind: "concurrency";
        /**
         * @generated from protobuf field: silo.v1.ConcurrencyLimit concurrency = 1
         */
        concurrency: ConcurrencyLimit;
    } | {
        oneofKind: "rateLimit";
        /**
         * @generated from protobuf field: silo.v1.GubernatorRateLimit rate_limit = 2
         */
        rateLimit: GubernatorRateLimit;
    } | {
        oneofKind: "floatingConcurrency";
        /**
         * @generated from protobuf field: silo.v1.FloatingConcurrencyLimit floating_concurrency = 3
         */
        floatingConcurrency: FloatingConcurrencyLimit;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message silo.v1.EnqueueRequest
 */
export interface EnqueueRequest {
    /**
     * @generated from protobuf field: uint32 shard = 1
     */
    shard: number; // shard id
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string; // optional
    /**
     * @generated from protobuf field: uint32 priority = 3
     */
    priority: number; // 0..99, 0 highest
    /**
     * @generated from protobuf field: int64 start_at_ms = 4
     */
    startAtMs: bigint; // epoch ms
    /**
     * @generated from protobuf field: optional silo.v1.RetryPolicy retry_policy = 5
     */
    retryPolicy?: RetryPolicy; // optional
    /**
     * @generated from protobuf field: silo.v1.JsonValueBytes payload = 6
     */
    payload?: JsonValueBytes; // JSON
    /**
     * @generated from protobuf field: repeated silo.v1.Limit limits = 7
     */
    limits: Limit[]; // ordered list of limits to check before execution
    /**
     * @generated from protobuf field: optional string tenant = 8
     */
    tenant?: string; // optional tenant id when tenancy is enabled
    /**
     * @generated from protobuf field: map<string, string> metadata = 9
     */
    metadata: {
        [key: string]: string;
    }; // arbitrary key/value metadata stored with the job
}
/**
 * @generated from protobuf message silo.v1.EnqueueResponse
 */
export interface EnqueueResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @generated from protobuf message silo.v1.GetJobRequest
 */
export interface GetJobRequest {
    /**
     * @generated from protobuf field: uint32 shard = 1
     */
    shard: number;
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string;
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string;
}
/**
 * @generated from protobuf message silo.v1.GetJobResponse
 */
export interface GetJobResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: uint32 priority = 2
     */
    priority: number;
    /**
     * @generated from protobuf field: int64 enqueue_time_ms = 3
     */
    enqueueTimeMs: bigint;
    /**
     * @generated from protobuf field: silo.v1.JsonValueBytes payload = 4
     */
    payload?: JsonValueBytes;
    /**
     * @generated from protobuf field: optional silo.v1.RetryPolicy retry_policy = 5
     */
    retryPolicy?: RetryPolicy; // presence indicates some policy
    /**
     * @generated from protobuf field: repeated silo.v1.Limit limits = 6
     */
    limits: Limit[]; // declared limits
    /**
     * @generated from protobuf field: map<string, string> metadata = 7
     */
    metadata: {
        [key: string]: string;
    }; // arbitrary key/value metadata stored with the job
    /**
     * @generated from protobuf field: silo.v1.JobStatus status = 8
     */
    status: JobStatus; // current job status
    /**
     * @generated from protobuf field: int64 status_changed_at_ms = 9
     */
    statusChangedAtMs: bigint; // when the status last changed (epoch ms)
}
/**
 * Get the result of a completed job.
 * Returns the job's result data if succeeded, error info if failed, or an error if the job
 * is not in a terminal state (still running/scheduled) or doesn't exist.
 *
 * @generated from protobuf message silo.v1.GetJobResultRequest
 */
export interface GetJobResultRequest {
    /**
     * @generated from protobuf field: uint32 shard = 1
     */
    shard: number;
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string;
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string;
}
/**
 * Response for GetJobResult - the result depends on the job's terminal state.
 * Use the oneof to determine which outcome occurred.
 *
 * @generated from protobuf message silo.v1.GetJobResultResponse
 */
export interface GetJobResultResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: silo.v1.JobStatus status = 2
     */
    status: JobStatus; // The terminal status: SUCCEEDED, FAILED, or CANCELLED
    /**
     * @generated from protobuf field: int64 finished_at_ms = 3
     */
    finishedAtMs: bigint; // When the job reached its terminal state (epoch ms)
    /**
     * The result data depends on the terminal status
     *
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "successData";
        /**
         * @generated from protobuf field: silo.v1.JsonValueBytes success_data = 4
         */
        successData: JsonValueBytes; // Result data if status == SUCCEEDED
    } | {
        oneofKind: "failure";
        /**
         * @generated from protobuf field: silo.v1.JobFailure failure = 5
         */
        failure: JobFailure; // Error info if status == FAILED
    } | {
        oneofKind: "cancelled";
        /**
         * @generated from protobuf field: silo.v1.JobCancelled cancelled = 6
         */
        cancelled: JobCancelled; // Cancellation info if status == CANCELLED
    } | {
        oneofKind: undefined;
    };
}
/**
 * Information about a failed job
 *
 * @generated from protobuf message silo.v1.JobFailure
 */
export interface JobFailure {
    /**
     * @generated from protobuf field: string error_code = 1
     */
    errorCode: string; // Application-defined error code
    /**
     * @generated from protobuf field: bytes error_data = 2
     */
    errorData: Uint8Array; // Error details (typically JSON)
}
/**
 * Information about a cancelled job
 *
 * @generated from protobuf message silo.v1.JobCancelled
 */
export interface JobCancelled {
    /**
     * @generated from protobuf field: int64 cancelled_at_ms = 1
     */
    cancelledAtMs: bigint; // When the job was cancelled (epoch ms)
}
/**
 * @generated from protobuf message silo.v1.DeleteJobRequest
 */
export interface DeleteJobRequest {
    /**
     * @generated from protobuf field: uint32 shard = 1
     */
    shard: number;
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string;
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string;
}
/**
 * @generated from protobuf message silo.v1.DeleteJobResponse
 */
export interface DeleteJobResponse {
}
/**
 * @generated from protobuf message silo.v1.CancelJobRequest
 */
export interface CancelJobRequest {
    /**
     * @generated from protobuf field: uint32 shard = 1
     */
    shard: number;
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string;
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string;
}
/**
 * @generated from protobuf message silo.v1.CancelJobResponse
 */
export interface CancelJobResponse {
}
/**
 * Lease tasks for processing from this server.
 * By default, leases from all shards this server owns (fair distribution).
 * If shard is specified, filters to only that shard.
 *
 * @generated from protobuf message silo.v1.LeaseTasksRequest
 */
export interface LeaseTasksRequest {
    /**
     * @generated from protobuf field: optional uint32 shard = 1
     */
    shard?: number; // optional filter - if set, only lease from this shard
    /**
     * @generated from protobuf field: string worker_id = 2
     */
    workerId: string;
    /**
     * @generated from protobuf field: uint32 max_tasks = 3
     */
    maxTasks: number;
}
/**
 * @generated from protobuf message silo.v1.Task
 */
export interface Task {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // task id
    /**
     * @generated from protobuf field: string job_id = 2
     */
    jobId: string;
    /**
     * @generated from protobuf field: uint32 attempt_number = 3
     */
    attemptNumber: number;
    /**
     * @generated from protobuf field: int64 lease_ms = 4
     */
    leaseMs: bigint; // how long to heartbeat in ms
    /**
     * @generated from protobuf field: silo.v1.JsonValueBytes payload = 5
     */
    payload?: JsonValueBytes; // job payload for convenience
    /**
     * @generated from protobuf field: uint32 priority = 6
     */
    priority: number;
    /**
     * @generated from protobuf field: uint32 shard = 7
     */
    shard: number; // which shard this task came from (for reporting outcomes)
}
/**
 * Task for refreshing a floating concurrency limit - workers compute new max concurrency
 *
 * @generated from protobuf message silo.v1.RefreshFloatingLimitTask
 */
export interface RefreshFloatingLimitTask {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // task id
    /**
     * @generated from protobuf field: string queue_key = 2
     */
    queueKey: string; // the floating limit queue key
    /**
     * @generated from protobuf field: uint32 current_max_concurrency = 3
     */
    currentMaxConcurrency: number; // the current max concurrency value
    /**
     * @generated from protobuf field: int64 last_refreshed_at_ms = 4
     */
    lastRefreshedAtMs: bigint; // when the value was last refreshed
    /**
     * @generated from protobuf field: map<string, string> metadata = 5
     */
    metadata: {
        [key: string]: string;
    }; // opaque metadata from the limit definition
    /**
     * @generated from protobuf field: int64 lease_ms = 6
     */
    leaseMs: bigint; // how long to heartbeat in ms
    /**
     * @generated from protobuf field: uint32 shard = 7
     */
    shard: number; // which shard this task came from (for reporting outcomes)
}
/**
 * @generated from protobuf message silo.v1.LeaseTasksResponse
 */
export interface LeaseTasksResponse {
    /**
     * @generated from protobuf field: repeated silo.v1.Task tasks = 1
     */
    tasks: Task[];
    /**
     * @generated from protobuf field: repeated silo.v1.RefreshFloatingLimitTask refresh_tasks = 2
     */
    refreshTasks: RefreshFloatingLimitTask[]; // floating limit refresh tasks
}
/**
 * Report the outcome of a job attempt task from a worker back to the server
 *
 * @generated from protobuf message silo.v1.ReportOutcomeRequest
 */
export interface ReportOutcomeRequest {
    /**
     * @generated from protobuf field: uint32 shard = 1
     */
    shard: number;
    /**
     * @generated from protobuf field: string task_id = 2
     */
    taskId: string;
    /**
     * @generated from protobuf field: optional string tenant = 5
     */
    tenant?: string;
    /**
     * @generated from protobuf oneof: outcome
     */
    outcome: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: silo.v1.JsonValueBytes success = 3
         */
        success: JsonValueBytes;
    } | {
        oneofKind: "failure";
        /**
         * @generated from protobuf field: silo.v1.Failure failure = 4
         */
        failure: Failure;
    } | {
        oneofKind: "cancelled";
        /**
         * @generated from protobuf field: silo.v1.Cancelled cancelled = 6
         */
        cancelled: Cancelled; // Worker acknowledges cancellation
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message silo.v1.Failure
 */
export interface Failure {
    /**
     * @generated from protobuf field: string code = 1
     */
    code: string;
    /**
     * @generated from protobuf field: bytes data = 2
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message silo.v1.Cancelled
 */
export interface Cancelled {
}
/**
 * @generated from protobuf message silo.v1.ReportOutcomeResponse
 */
export interface ReportOutcomeResponse {
}
/**
 * Report the outcome of a floating limit refresh task from a worker back to the server
 *
 * @generated from protobuf message silo.v1.ReportRefreshOutcomeRequest
 */
export interface ReportRefreshOutcomeRequest {
    /**
     * @generated from protobuf field: uint32 shard = 1
     */
    shard: number;
    /**
     * @generated from protobuf field: string task_id = 2
     */
    taskId: string;
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string;
    /**
     * @generated from protobuf oneof: outcome
     */
    outcome: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: silo.v1.RefreshSuccess success = 4
         */
        success: RefreshSuccess;
    } | {
        oneofKind: "failure";
        /**
         * @generated from protobuf field: silo.v1.RefreshFailure failure = 5
         */
        failure: RefreshFailure;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message silo.v1.RefreshSuccess
 */
export interface RefreshSuccess {
    /**
     * @generated from protobuf field: uint32 new_max_concurrency = 1
     */
    newMaxConcurrency: number; // the new max concurrency value computed by the worker
}
/**
 * @generated from protobuf message silo.v1.RefreshFailure
 */
export interface RefreshFailure {
    /**
     * @generated from protobuf field: string code = 1
     */
    code: string; // error code
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string; // error message
}
/**
 * @generated from protobuf message silo.v1.ReportRefreshOutcomeResponse
 */
export interface ReportRefreshOutcomeResponse {
}
/**
 * @generated from protobuf message silo.v1.HeartbeatRequest
 */
export interface HeartbeatRequest {
    /**
     * @generated from protobuf field: uint32 shard = 1
     */
    shard: number;
    /**
     * @generated from protobuf field: string worker_id = 2
     */
    workerId: string;
    /**
     * @generated from protobuf field: string task_id = 3
     */
    taskId: string;
    /**
     * @generated from protobuf field: optional string tenant = 4
     */
    tenant?: string;
}
/**
 * @generated from protobuf message silo.v1.HeartbeatResponse
 */
export interface HeartbeatResponse {
    /**
     * True if the job has been cancelled. Worker should stop work and report Cancelled outcome.
     *
     * @generated from protobuf field: bool cancelled = 1
     */
    cancelled: boolean;
    /**
     * Timestamp (epoch ms) when cancellation was requested, if cancelled
     *
     * @generated from protobuf field: optional int64 cancelled_at_ms = 2
     */
    cancelledAtMs?: bigint;
}
/**
 * Execute an arbitrary SQL query against shard data
 *
 * @generated from protobuf message silo.v1.QueryRequest
 */
export interface QueryRequest {
    /**
     * @generated from protobuf field: uint32 shard = 1
     */
    shard: number;
    /**
     * @generated from protobuf field: string sql = 2
     */
    sql: string;
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string;
}
/**
 * Column metadata for the result schema
 *
 * @generated from protobuf message silo.v1.ColumnInfo
 */
export interface ColumnInfo {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: string data_type = 2
     */
    dataType: string; // Arrow/DataFusion type as string (e.g. "Utf8", "Int64", "UInt8")
}
/**
 * Query result row as JSON object
 *
 * @generated from protobuf message silo.v1.QueryResponse
 */
export interface QueryResponse {
    /**
     * @generated from protobuf field: repeated silo.v1.ColumnInfo columns = 1
     */
    columns: ColumnInfo[]; // Schema information
    /**
     * @generated from protobuf field: repeated silo.v1.JsonValueBytes rows = 2
     */
    rows: JsonValueBytes[]; // Each row is a JSON object
    /**
     * @generated from protobuf field: int32 row_count = 3
     */
    rowCount: number; // Number of rows returned
}
/**
 * Execute SQL query with Arrow IPC streaming response
 *
 * @generated from protobuf message silo.v1.QueryArrowRequest
 */
export interface QueryArrowRequest {
    /**
     * @generated from protobuf field: uint32 shard = 1
     */
    shard: number;
    /**
     * @generated from protobuf field: string sql = 2
     */
    sql: string;
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string;
}
/**
 * Arrow IPC encoded schema or record batch
 *
 * @generated from protobuf message silo.v1.ArrowIpcMessage
 */
export interface ArrowIpcMessage {
    /**
     * Arrow IPC stream format: first message is schema, subsequent are record batches
     *
     * @generated from protobuf field: bytes ipc_data = 1
     */
    ipcData: Uint8Array;
}
/**
 * Cluster topology information for client-side routing
 *
 * @generated from protobuf message silo.v1.GetClusterInfoRequest
 */
export interface GetClusterInfoRequest {
}
/**
 * @generated from protobuf message silo.v1.ShardOwner
 */
export interface ShardOwner {
    /**
     * @generated from protobuf field: uint32 shard_id = 1
     */
    shardId: number;
    /**
     * @generated from protobuf field: string grpc_addr = 2
     */
    grpcAddr: string; // The gRPC address of the server owning this shard
    /**
     * @generated from protobuf field: string node_id = 3
     */
    nodeId: string; // The node ID of the owner
}
/**
 * @generated from protobuf message silo.v1.GetClusterInfoResponse
 */
export interface GetClusterInfoResponse {
    /**
     * @generated from protobuf field: uint32 num_shards = 1
     */
    numShards: number; // Total number of shards in the cluster
    /**
     * @generated from protobuf field: repeated silo.v1.ShardOwner shard_owners = 2
     */
    shardOwners: ShardOwner[]; // Mapping of shards to their owners
    /**
     * @generated from protobuf field: string this_node_id = 3
     */
    thisNodeId: string; // The node ID of the server responding
    /**
     * @generated from protobuf field: string this_grpc_addr = 4
     */
    thisGrpcAddr: string; // The gRPC address of the server responding
}
/**
 * Admin request to reset all shards (dev mode only)
 * This clears all data from all shards owned by this server.
 * WARNING: This is a destructive operation intended only for testing.
 *
 * @generated from protobuf message silo.v1.ResetShardsRequest
 */
export interface ResetShardsRequest {
}
/**
 * @generated from protobuf message silo.v1.ResetShardsResponse
 */
export interface ResetShardsResponse {
    /**
     * @generated from protobuf field: uint32 shards_reset = 1
     */
    shardsReset: number; // Number of shards that were reset
}
/**
 * Gubernator rate limiting algorithm
 *
 * @generated from protobuf enum silo.v1.GubernatorAlgorithm
 */
export enum GubernatorAlgorithm {
    /**
     * Token bucket algorithm
     *
     * @generated from protobuf enum value: GUBERNATOR_ALGORITHM_TOKEN_BUCKET = 0;
     */
    TOKEN_BUCKET = 0,
    /**
     * Leaky bucket algorithm
     *
     * @generated from protobuf enum value: GUBERNATOR_ALGORITHM_LEAKY_BUCKET = 1;
     */
    LEAKY_BUCKET = 1
}
/**
 * Gubernator behavior flags (can be combined via bitwise OR)
 *
 * @generated from protobuf enum silo.v1.GubernatorBehavior
 */
export enum GubernatorBehavior {
    /**
     * Default: batch requests to peers
     *
     * @generated from protobuf enum value: GUBERNATOR_BEHAVIOR_BATCHING = 0;
     */
    BATCHING = 0,
    /**
     * Disable batching
     *
     * @generated from protobuf enum value: GUBERNATOR_BEHAVIOR_NO_BATCHING = 1;
     */
    NO_BATCHING = 1,
    /**
     * Global rate limit across all peers
     *
     * @generated from protobuf enum value: GUBERNATOR_BEHAVIOR_GLOBAL = 2;
     */
    GLOBAL = 2,
    /**
     * Duration resets on calendar boundaries
     *
     * @generated from protobuf enum value: GUBERNATOR_BEHAVIOR_DURATION_IS_GREGORIAN = 4;
     */
    DURATION_IS_GREGORIAN = 4,
    /**
     * Reset the rate limit on this request
     *
     * @generated from protobuf enum value: GUBERNATOR_BEHAVIOR_RESET_REMAINING = 8;
     */
    RESET_REMAINING = 8,
    /**
     * Drain remaining counter on over limit
     *
     * @generated from protobuf enum value: GUBERNATOR_BEHAVIOR_DRAIN_OVER_LIMIT = 16;
     */
    DRAIN_OVER_LIMIT = 16
}
/**
 * Job status enum representing the current state of a job
 *
 * @generated from protobuf enum silo.v1.JobStatus
 */
export enum JobStatus {
    /**
     * Job is waiting to be executed
     *
     * @generated from protobuf enum value: JOB_STATUS_SCHEDULED = 0;
     */
    SCHEDULED = 0,
    /**
     * Job is currently being processed by a worker
     *
     * @generated from protobuf enum value: JOB_STATUS_RUNNING = 1;
     */
    RUNNING = 1,
    /**
     * Job completed successfully
     *
     * @generated from protobuf enum value: JOB_STATUS_SUCCEEDED = 2;
     */
    SUCCEEDED = 2,
    /**
     * Job failed after exhausting all retries
     *
     * @generated from protobuf enum value: JOB_STATUS_FAILED = 3;
     */
    FAILED = 3,
    /**
     * Job was cancelled before completion
     *
     * @generated from protobuf enum value: JOB_STATUS_CANCELLED = 4;
     */
    CANCELLED = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class JsonValueBytes$Type extends MessageType<JsonValueBytes> {
    constructor() {
        super("silo.v1.JsonValueBytes", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<JsonValueBytes>): JsonValueBytes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<JsonValueBytes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JsonValueBytes): JsonValueBytes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JsonValueBytes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.JsonValueBytes
 */
export const JsonValueBytes = new JsonValueBytes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetryPolicy$Type extends MessageType<RetryPolicy> {
    constructor() {
        super("silo.v1.RetryPolicy", [
            { no: 1, name: "retry_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "initial_interval_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "max_interval_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "randomize_interval", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "backoff_factor", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<RetryPolicy>): RetryPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.retryCount = 0;
        message.initialIntervalMs = 0n;
        message.maxIntervalMs = 0n;
        message.randomizeInterval = false;
        message.backoffFactor = 0;
        if (value !== undefined)
            reflectionMergePartial<RetryPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetryPolicy): RetryPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 retry_count */ 1:
                    message.retryCount = reader.uint32();
                    break;
                case /* int64 initial_interval_ms */ 2:
                    message.initialIntervalMs = reader.int64().toBigInt();
                    break;
                case /* int64 max_interval_ms */ 3:
                    message.maxIntervalMs = reader.int64().toBigInt();
                    break;
                case /* bool randomize_interval */ 4:
                    message.randomizeInterval = reader.bool();
                    break;
                case /* double backoff_factor */ 5:
                    message.backoffFactor = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetryPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 retry_count = 1; */
        if (message.retryCount !== 0)
            writer.tag(1, WireType.Varint).uint32(message.retryCount);
        /* int64 initial_interval_ms = 2; */
        if (message.initialIntervalMs !== 0n)
            writer.tag(2, WireType.Varint).int64(message.initialIntervalMs);
        /* int64 max_interval_ms = 3; */
        if (message.maxIntervalMs !== 0n)
            writer.tag(3, WireType.Varint).int64(message.maxIntervalMs);
        /* bool randomize_interval = 4; */
        if (message.randomizeInterval !== false)
            writer.tag(4, WireType.Varint).bool(message.randomizeInterval);
        /* double backoff_factor = 5; */
        if (message.backoffFactor !== 0)
            writer.tag(5, WireType.Bit64).double(message.backoffFactor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.RetryPolicy
 */
export const RetryPolicy = new RetryPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConcurrencyLimit$Type extends MessageType<ConcurrencyLimit> {
    constructor() {
        super("silo.v1.ConcurrencyLimit", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "max_concurrency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ConcurrencyLimit>): ConcurrencyLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.maxConcurrency = 0;
        if (value !== undefined)
            reflectionMergePartial<ConcurrencyLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConcurrencyLimit): ConcurrencyLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* uint32 max_concurrency */ 2:
                    message.maxConcurrency = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConcurrencyLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* uint32 max_concurrency = 2; */
        if (message.maxConcurrency !== 0)
            writer.tag(2, WireType.Varint).uint32(message.maxConcurrency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ConcurrencyLimit
 */
export const ConcurrencyLimit = new ConcurrencyLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FloatingConcurrencyLimit$Type extends MessageType<FloatingConcurrencyLimit> {
    constructor() {
        super("silo.v1.FloatingConcurrencyLimit", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "default_max_concurrency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "refresh_interval_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<FloatingConcurrencyLimit>): FloatingConcurrencyLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.defaultMaxConcurrency = 0;
        message.refreshIntervalMs = 0n;
        message.metadata = {};
        if (value !== undefined)
            reflectionMergePartial<FloatingConcurrencyLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FloatingConcurrencyLimit): FloatingConcurrencyLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* uint32 default_max_concurrency */ 2:
                    message.defaultMaxConcurrency = reader.uint32();
                    break;
                case /* int64 refresh_interval_ms */ 3:
                    message.refreshIntervalMs = reader.int64().toBigInt();
                    break;
                case /* map<string, string> metadata */ 4:
                    this.binaryReadMap4(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: FloatingConcurrencyLimit["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof FloatingConcurrencyLimit["metadata"] | undefined, val: FloatingConcurrencyLimit["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for silo.v1.FloatingConcurrencyLimit.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: FloatingConcurrencyLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* uint32 default_max_concurrency = 2; */
        if (message.defaultMaxConcurrency !== 0)
            writer.tag(2, WireType.Varint).uint32(message.defaultMaxConcurrency);
        /* int64 refresh_interval_ms = 3; */
        if (message.refreshIntervalMs !== 0n)
            writer.tag(3, WireType.Varint).int64(message.refreshIntervalMs);
        /* map<string, string> metadata = 4; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.FloatingConcurrencyLimit
 */
export const FloatingConcurrencyLimit = new FloatingConcurrencyLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitRetryPolicy$Type extends MessageType<RateLimitRetryPolicy> {
    constructor() {
        super("silo.v1.RateLimitRetryPolicy", [
            { no: 1, name: "initial_backoff_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "max_backoff_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "backoff_multiplier", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "max_retries", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RateLimitRetryPolicy>): RateLimitRetryPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.initialBackoffMs = 0n;
        message.maxBackoffMs = 0n;
        message.backoffMultiplier = 0;
        message.maxRetries = 0;
        if (value !== undefined)
            reflectionMergePartial<RateLimitRetryPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitRetryPolicy): RateLimitRetryPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 initial_backoff_ms */ 1:
                    message.initialBackoffMs = reader.int64().toBigInt();
                    break;
                case /* int64 max_backoff_ms */ 2:
                    message.maxBackoffMs = reader.int64().toBigInt();
                    break;
                case /* double backoff_multiplier */ 3:
                    message.backoffMultiplier = reader.double();
                    break;
                case /* uint32 max_retries */ 4:
                    message.maxRetries = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitRetryPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 initial_backoff_ms = 1; */
        if (message.initialBackoffMs !== 0n)
            writer.tag(1, WireType.Varint).int64(message.initialBackoffMs);
        /* int64 max_backoff_ms = 2; */
        if (message.maxBackoffMs !== 0n)
            writer.tag(2, WireType.Varint).int64(message.maxBackoffMs);
        /* double backoff_multiplier = 3; */
        if (message.backoffMultiplier !== 0)
            writer.tag(3, WireType.Bit64).double(message.backoffMultiplier);
        /* uint32 max_retries = 4; */
        if (message.maxRetries !== 0)
            writer.tag(4, WireType.Varint).uint32(message.maxRetries);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.RateLimitRetryPolicy
 */
export const RateLimitRetryPolicy = new RateLimitRetryPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GubernatorRateLimit$Type extends MessageType<GubernatorRateLimit> {
    constructor() {
        super("silo.v1.GubernatorRateLimit", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "unique_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "limit", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "duration_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "hits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "algorithm", kind: "enum", T: () => ["silo.v1.GubernatorAlgorithm", GubernatorAlgorithm, "GUBERNATOR_ALGORITHM_"] },
            { no: 7, name: "behavior", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "retry_policy", kind: "message", T: () => RateLimitRetryPolicy }
        ]);
    }
    create(value?: PartialMessage<GubernatorRateLimit>): GubernatorRateLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.uniqueKey = "";
        message.limit = 0n;
        message.durationMs = 0n;
        message.hits = 0;
        message.algorithm = 0;
        message.behavior = 0;
        if (value !== undefined)
            reflectionMergePartial<GubernatorRateLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GubernatorRateLimit): GubernatorRateLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string unique_key */ 2:
                    message.uniqueKey = reader.string();
                    break;
                case /* int64 limit */ 3:
                    message.limit = reader.int64().toBigInt();
                    break;
                case /* int64 duration_ms */ 4:
                    message.durationMs = reader.int64().toBigInt();
                    break;
                case /* int32 hits */ 5:
                    message.hits = reader.int32();
                    break;
                case /* silo.v1.GubernatorAlgorithm algorithm */ 6:
                    message.algorithm = reader.int32();
                    break;
                case /* int32 behavior */ 7:
                    message.behavior = reader.int32();
                    break;
                case /* silo.v1.RateLimitRetryPolicy retry_policy */ 8:
                    message.retryPolicy = RateLimitRetryPolicy.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GubernatorRateLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string unique_key = 2; */
        if (message.uniqueKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uniqueKey);
        /* int64 limit = 3; */
        if (message.limit !== 0n)
            writer.tag(3, WireType.Varint).int64(message.limit);
        /* int64 duration_ms = 4; */
        if (message.durationMs !== 0n)
            writer.tag(4, WireType.Varint).int64(message.durationMs);
        /* int32 hits = 5; */
        if (message.hits !== 0)
            writer.tag(5, WireType.Varint).int32(message.hits);
        /* silo.v1.GubernatorAlgorithm algorithm = 6; */
        if (message.algorithm !== 0)
            writer.tag(6, WireType.Varint).int32(message.algorithm);
        /* int32 behavior = 7; */
        if (message.behavior !== 0)
            writer.tag(7, WireType.Varint).int32(message.behavior);
        /* silo.v1.RateLimitRetryPolicy retry_policy = 8; */
        if (message.retryPolicy)
            RateLimitRetryPolicy.internalBinaryWrite(message.retryPolicy, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GubernatorRateLimit
 */
export const GubernatorRateLimit = new GubernatorRateLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Limit$Type extends MessageType<Limit> {
    constructor() {
        super("silo.v1.Limit", [
            { no: 1, name: "concurrency", kind: "message", oneof: "limit", T: () => ConcurrencyLimit },
            { no: 2, name: "rate_limit", kind: "message", oneof: "limit", T: () => GubernatorRateLimit },
            { no: 3, name: "floating_concurrency", kind: "message", oneof: "limit", T: () => FloatingConcurrencyLimit }
        ]);
    }
    create(value?: PartialMessage<Limit>): Limit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.limit = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Limit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Limit): Limit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* silo.v1.ConcurrencyLimit concurrency */ 1:
                    message.limit = {
                        oneofKind: "concurrency",
                        concurrency: ConcurrencyLimit.internalBinaryRead(reader, reader.uint32(), options, (message.limit as any).concurrency)
                    };
                    break;
                case /* silo.v1.GubernatorRateLimit rate_limit */ 2:
                    message.limit = {
                        oneofKind: "rateLimit",
                        rateLimit: GubernatorRateLimit.internalBinaryRead(reader, reader.uint32(), options, (message.limit as any).rateLimit)
                    };
                    break;
                case /* silo.v1.FloatingConcurrencyLimit floating_concurrency */ 3:
                    message.limit = {
                        oneofKind: "floatingConcurrency",
                        floatingConcurrency: FloatingConcurrencyLimit.internalBinaryRead(reader, reader.uint32(), options, (message.limit as any).floatingConcurrency)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Limit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* silo.v1.ConcurrencyLimit concurrency = 1; */
        if (message.limit.oneofKind === "concurrency")
            ConcurrencyLimit.internalBinaryWrite(message.limit.concurrency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.GubernatorRateLimit rate_limit = 2; */
        if (message.limit.oneofKind === "rateLimit")
            GubernatorRateLimit.internalBinaryWrite(message.limit.rateLimit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.FloatingConcurrencyLimit floating_concurrency = 3; */
        if (message.limit.oneofKind === "floatingConcurrency")
            FloatingConcurrencyLimit.internalBinaryWrite(message.limit.floatingConcurrency, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.Limit
 */
export const Limit = new Limit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnqueueRequest$Type extends MessageType<EnqueueRequest> {
    constructor() {
        super("silo.v1.EnqueueRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "priority", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "start_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "retry_policy", kind: "message", T: () => RetryPolicy },
            { no: 6, name: "payload", kind: "message", T: () => JsonValueBytes },
            { no: 7, name: "limits", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Limit },
            { no: 8, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<EnqueueRequest>): EnqueueRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = 0;
        message.id = "";
        message.priority = 0;
        message.startAtMs = 0n;
        message.limits = [];
        message.metadata = {};
        if (value !== undefined)
            reflectionMergePartial<EnqueueRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnqueueRequest): EnqueueRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shard */ 1:
                    message.shard = reader.uint32();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* uint32 priority */ 3:
                    message.priority = reader.uint32();
                    break;
                case /* int64 start_at_ms */ 4:
                    message.startAtMs = reader.int64().toBigInt();
                    break;
                case /* optional silo.v1.RetryPolicy retry_policy */ 5:
                    message.retryPolicy = RetryPolicy.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicy);
                    break;
                case /* silo.v1.JsonValueBytes payload */ 6:
                    message.payload = JsonValueBytes.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                case /* repeated silo.v1.Limit limits */ 7:
                    message.limits.push(Limit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string tenant */ 8:
                    message.tenant = reader.string();
                    break;
                case /* map<string, string> metadata */ 9:
                    this.binaryReadMap9(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: EnqueueRequest["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EnqueueRequest["metadata"] | undefined, val: EnqueueRequest["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for silo.v1.EnqueueRequest.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: EnqueueRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shard = 1; */
        if (message.shard !== 0)
            writer.tag(1, WireType.Varint).uint32(message.shard);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* uint32 priority = 3; */
        if (message.priority !== 0)
            writer.tag(3, WireType.Varint).uint32(message.priority);
        /* int64 start_at_ms = 4; */
        if (message.startAtMs !== 0n)
            writer.tag(4, WireType.Varint).int64(message.startAtMs);
        /* optional silo.v1.RetryPolicy retry_policy = 5; */
        if (message.retryPolicy)
            RetryPolicy.internalBinaryWrite(message.retryPolicy, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.JsonValueBytes payload = 6; */
        if (message.payload)
            JsonValueBytes.internalBinaryWrite(message.payload, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated silo.v1.Limit limits = 7; */
        for (let i = 0; i < message.limits.length; i++)
            Limit.internalBinaryWrite(message.limits[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional string tenant = 8; */
        if (message.tenant !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.tenant);
        /* map<string, string> metadata = 9; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.EnqueueRequest
 */
export const EnqueueRequest = new EnqueueRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnqueueResponse$Type extends MessageType<EnqueueResponse> {
    constructor() {
        super("silo.v1.EnqueueResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EnqueueResponse>): EnqueueResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<EnqueueResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnqueueResponse): EnqueueResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnqueueResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.EnqueueResponse
 */
export const EnqueueResponse = new EnqueueResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetJobRequest$Type extends MessageType<GetJobRequest> {
    constructor() {
        super("silo.v1.GetJobRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetJobRequest>): GetJobRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = 0;
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GetJobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJobRequest): GetJobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shard */ 1:
                    message.shard = reader.uint32();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetJobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shard = 1; */
        if (message.shard !== 0)
            writer.tag(1, WireType.Varint).uint32(message.shard);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetJobRequest
 */
export const GetJobRequest = new GetJobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetJobResponse$Type extends MessageType<GetJobResponse> {
    constructor() {
        super("silo.v1.GetJobResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "priority", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "enqueue_time_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "payload", kind: "message", T: () => JsonValueBytes },
            { no: 5, name: "retry_policy", kind: "message", T: () => RetryPolicy },
            { no: 6, name: "limits", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Limit },
            { no: 7, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 8, name: "status", kind: "enum", T: () => ["silo.v1.JobStatus", JobStatus, "JOB_STATUS_"] },
            { no: 9, name: "status_changed_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetJobResponse>): GetJobResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.priority = 0;
        message.enqueueTimeMs = 0n;
        message.limits = [];
        message.metadata = {};
        message.status = 0;
        message.statusChangedAtMs = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetJobResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJobResponse): GetJobResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* uint32 priority */ 2:
                    message.priority = reader.uint32();
                    break;
                case /* int64 enqueue_time_ms */ 3:
                    message.enqueueTimeMs = reader.int64().toBigInt();
                    break;
                case /* silo.v1.JsonValueBytes payload */ 4:
                    message.payload = JsonValueBytes.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                case /* optional silo.v1.RetryPolicy retry_policy */ 5:
                    message.retryPolicy = RetryPolicy.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicy);
                    break;
                case /* repeated silo.v1.Limit limits */ 6:
                    message.limits.push(Limit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<string, string> metadata */ 7:
                    this.binaryReadMap7(message.metadata, reader, options);
                    break;
                case /* silo.v1.JobStatus status */ 8:
                    message.status = reader.int32();
                    break;
                case /* int64 status_changed_at_ms */ 9:
                    message.statusChangedAtMs = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: GetJobResponse["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetJobResponse["metadata"] | undefined, val: GetJobResponse["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for silo.v1.GetJobResponse.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: GetJobResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* uint32 priority = 2; */
        if (message.priority !== 0)
            writer.tag(2, WireType.Varint).uint32(message.priority);
        /* int64 enqueue_time_ms = 3; */
        if (message.enqueueTimeMs !== 0n)
            writer.tag(3, WireType.Varint).int64(message.enqueueTimeMs);
        /* silo.v1.JsonValueBytes payload = 4; */
        if (message.payload)
            JsonValueBytes.internalBinaryWrite(message.payload, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional silo.v1.RetryPolicy retry_policy = 5; */
        if (message.retryPolicy)
            RetryPolicy.internalBinaryWrite(message.retryPolicy, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated silo.v1.Limit limits = 6; */
        for (let i = 0; i < message.limits.length; i++)
            Limit.internalBinaryWrite(message.limits[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> metadata = 7; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        /* silo.v1.JobStatus status = 8; */
        if (message.status !== 0)
            writer.tag(8, WireType.Varint).int32(message.status);
        /* int64 status_changed_at_ms = 9; */
        if (message.statusChangedAtMs !== 0n)
            writer.tag(9, WireType.Varint).int64(message.statusChangedAtMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetJobResponse
 */
export const GetJobResponse = new GetJobResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetJobResultRequest$Type extends MessageType<GetJobResultRequest> {
    constructor() {
        super("silo.v1.GetJobResultRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetJobResultRequest>): GetJobResultRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = 0;
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GetJobResultRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJobResultRequest): GetJobResultRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shard */ 1:
                    message.shard = reader.uint32();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetJobResultRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shard = 1; */
        if (message.shard !== 0)
            writer.tag(1, WireType.Varint).uint32(message.shard);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetJobResultRequest
 */
export const GetJobResultRequest = new GetJobResultRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetJobResultResponse$Type extends MessageType<GetJobResultResponse> {
    constructor() {
        super("silo.v1.GetJobResultResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["silo.v1.JobStatus", JobStatus, "JOB_STATUS_"] },
            { no: 3, name: "finished_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "success_data", kind: "message", oneof: "result", T: () => JsonValueBytes },
            { no: 5, name: "failure", kind: "message", oneof: "result", T: () => JobFailure },
            { no: 6, name: "cancelled", kind: "message", oneof: "result", T: () => JobCancelled }
        ]);
    }
    create(value?: PartialMessage<GetJobResultResponse>): GetJobResultResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.status = 0;
        message.finishedAtMs = 0n;
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<GetJobResultResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJobResultResponse): GetJobResultResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* silo.v1.JobStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* int64 finished_at_ms */ 3:
                    message.finishedAtMs = reader.int64().toBigInt();
                    break;
                case /* silo.v1.JsonValueBytes success_data */ 4:
                    message.result = {
                        oneofKind: "successData",
                        successData: JsonValueBytes.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).successData)
                    };
                    break;
                case /* silo.v1.JobFailure failure */ 5:
                    message.result = {
                        oneofKind: "failure",
                        failure: JobFailure.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).failure)
                    };
                    break;
                case /* silo.v1.JobCancelled cancelled */ 6:
                    message.result = {
                        oneofKind: "cancelled",
                        cancelled: JobCancelled.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).cancelled)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetJobResultResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* silo.v1.JobStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* int64 finished_at_ms = 3; */
        if (message.finishedAtMs !== 0n)
            writer.tag(3, WireType.Varint).int64(message.finishedAtMs);
        /* silo.v1.JsonValueBytes success_data = 4; */
        if (message.result.oneofKind === "successData")
            JsonValueBytes.internalBinaryWrite(message.result.successData, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.JobFailure failure = 5; */
        if (message.result.oneofKind === "failure")
            JobFailure.internalBinaryWrite(message.result.failure, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.JobCancelled cancelled = 6; */
        if (message.result.oneofKind === "cancelled")
            JobCancelled.internalBinaryWrite(message.result.cancelled, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetJobResultResponse
 */
export const GetJobResultResponse = new GetJobResultResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobFailure$Type extends MessageType<JobFailure> {
    constructor() {
        super("silo.v1.JobFailure", [
            { no: 1, name: "error_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<JobFailure>): JobFailure {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.errorCode = "";
        message.errorData = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<JobFailure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobFailure): JobFailure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error_code */ 1:
                    message.errorCode = reader.string();
                    break;
                case /* bytes error_data */ 2:
                    message.errorData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobFailure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error_code = 1; */
        if (message.errorCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.errorCode);
        /* bytes error_data = 2; */
        if (message.errorData.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.errorData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.JobFailure
 */
export const JobFailure = new JobFailure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobCancelled$Type extends MessageType<JobCancelled> {
    constructor() {
        super("silo.v1.JobCancelled", [
            { no: 1, name: "cancelled_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<JobCancelled>): JobCancelled {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cancelledAtMs = 0n;
        if (value !== undefined)
            reflectionMergePartial<JobCancelled>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobCancelled): JobCancelled {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 cancelled_at_ms */ 1:
                    message.cancelledAtMs = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobCancelled, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 cancelled_at_ms = 1; */
        if (message.cancelledAtMs !== 0n)
            writer.tag(1, WireType.Varint).int64(message.cancelledAtMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.JobCancelled
 */
export const JobCancelled = new JobCancelled$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteJobRequest$Type extends MessageType<DeleteJobRequest> {
    constructor() {
        super("silo.v1.DeleteJobRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteJobRequest>): DeleteJobRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = 0;
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteJobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteJobRequest): DeleteJobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shard */ 1:
                    message.shard = reader.uint32();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteJobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shard = 1; */
        if (message.shard !== 0)
            writer.tag(1, WireType.Varint).uint32(message.shard);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.DeleteJobRequest
 */
export const DeleteJobRequest = new DeleteJobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteJobResponse$Type extends MessageType<DeleteJobResponse> {
    constructor() {
        super("silo.v1.DeleteJobResponse", []);
    }
    create(value?: PartialMessage<DeleteJobResponse>): DeleteJobResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteJobResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteJobResponse): DeleteJobResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteJobResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.DeleteJobResponse
 */
export const DeleteJobResponse = new DeleteJobResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelJobRequest$Type extends MessageType<CancelJobRequest> {
    constructor() {
        super("silo.v1.CancelJobRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CancelJobRequest>): CancelJobRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = 0;
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<CancelJobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelJobRequest): CancelJobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shard */ 1:
                    message.shard = reader.uint32();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelJobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shard = 1; */
        if (message.shard !== 0)
            writer.tag(1, WireType.Varint).uint32(message.shard);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.CancelJobRequest
 */
export const CancelJobRequest = new CancelJobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelJobResponse$Type extends MessageType<CancelJobResponse> {
    constructor() {
        super("silo.v1.CancelJobResponse", []);
    }
    create(value?: PartialMessage<CancelJobResponse>): CancelJobResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CancelJobResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelJobResponse): CancelJobResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelJobResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.CancelJobResponse
 */
export const CancelJobResponse = new CancelJobResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaseTasksRequest$Type extends MessageType<LeaseTasksRequest> {
    constructor() {
        super("silo.v1.LeaseTasksRequest", [
            { no: 1, name: "shard", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "worker_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "max_tasks", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LeaseTasksRequest>): LeaseTasksRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerId = "";
        message.maxTasks = 0;
        if (value !== undefined)
            reflectionMergePartial<LeaseTasksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaseTasksRequest): LeaseTasksRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 shard */ 1:
                    message.shard = reader.uint32();
                    break;
                case /* string worker_id */ 2:
                    message.workerId = reader.string();
                    break;
                case /* uint32 max_tasks */ 3:
                    message.maxTasks = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaseTasksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 shard = 1; */
        if (message.shard !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.shard);
        /* string worker_id = 2; */
        if (message.workerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.workerId);
        /* uint32 max_tasks = 3; */
        if (message.maxTasks !== 0)
            writer.tag(3, WireType.Varint).uint32(message.maxTasks);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.LeaseTasksRequest
 */
export const LeaseTasksRequest = new LeaseTasksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Task$Type extends MessageType<Task> {
    constructor() {
        super("silo.v1.Task", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "job_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "attempt_number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "lease_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "payload", kind: "message", T: () => JsonValueBytes },
            { no: 6, name: "priority", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "shard", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Task>): Task {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.jobId = "";
        message.attemptNumber = 0;
        message.leaseMs = 0n;
        message.priority = 0;
        message.shard = 0;
        if (value !== undefined)
            reflectionMergePartial<Task>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Task): Task {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string job_id */ 2:
                    message.jobId = reader.string();
                    break;
                case /* uint32 attempt_number */ 3:
                    message.attemptNumber = reader.uint32();
                    break;
                case /* int64 lease_ms */ 4:
                    message.leaseMs = reader.int64().toBigInt();
                    break;
                case /* silo.v1.JsonValueBytes payload */ 5:
                    message.payload = JsonValueBytes.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                case /* uint32 priority */ 6:
                    message.priority = reader.uint32();
                    break;
                case /* uint32 shard */ 7:
                    message.shard = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Task, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string job_id = 2; */
        if (message.jobId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.jobId);
        /* uint32 attempt_number = 3; */
        if (message.attemptNumber !== 0)
            writer.tag(3, WireType.Varint).uint32(message.attemptNumber);
        /* int64 lease_ms = 4; */
        if (message.leaseMs !== 0n)
            writer.tag(4, WireType.Varint).int64(message.leaseMs);
        /* silo.v1.JsonValueBytes payload = 5; */
        if (message.payload)
            JsonValueBytes.internalBinaryWrite(message.payload, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* uint32 priority = 6; */
        if (message.priority !== 0)
            writer.tag(6, WireType.Varint).uint32(message.priority);
        /* uint32 shard = 7; */
        if (message.shard !== 0)
            writer.tag(7, WireType.Varint).uint32(message.shard);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.Task
 */
export const Task = new Task$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshFloatingLimitTask$Type extends MessageType<RefreshFloatingLimitTask> {
    constructor() {
        super("silo.v1.RefreshFloatingLimitTask", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "queue_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "current_max_concurrency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "last_refreshed_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 6, name: "lease_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "shard", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RefreshFloatingLimitTask>): RefreshFloatingLimitTask {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.queueKey = "";
        message.currentMaxConcurrency = 0;
        message.lastRefreshedAtMs = 0n;
        message.metadata = {};
        message.leaseMs = 0n;
        message.shard = 0;
        if (value !== undefined)
            reflectionMergePartial<RefreshFloatingLimitTask>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshFloatingLimitTask): RefreshFloatingLimitTask {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string queue_key */ 2:
                    message.queueKey = reader.string();
                    break;
                case /* uint32 current_max_concurrency */ 3:
                    message.currentMaxConcurrency = reader.uint32();
                    break;
                case /* int64 last_refreshed_at_ms */ 4:
                    message.lastRefreshedAtMs = reader.int64().toBigInt();
                    break;
                case /* map<string, string> metadata */ 5:
                    this.binaryReadMap5(message.metadata, reader, options);
                    break;
                case /* int64 lease_ms */ 6:
                    message.leaseMs = reader.int64().toBigInt();
                    break;
                case /* uint32 shard */ 7:
                    message.shard = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: RefreshFloatingLimitTask["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof RefreshFloatingLimitTask["metadata"] | undefined, val: RefreshFloatingLimitTask["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for silo.v1.RefreshFloatingLimitTask.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: RefreshFloatingLimitTask, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string queue_key = 2; */
        if (message.queueKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.queueKey);
        /* uint32 current_max_concurrency = 3; */
        if (message.currentMaxConcurrency !== 0)
            writer.tag(3, WireType.Varint).uint32(message.currentMaxConcurrency);
        /* int64 last_refreshed_at_ms = 4; */
        if (message.lastRefreshedAtMs !== 0n)
            writer.tag(4, WireType.Varint).int64(message.lastRefreshedAtMs);
        /* map<string, string> metadata = 5; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        /* int64 lease_ms = 6; */
        if (message.leaseMs !== 0n)
            writer.tag(6, WireType.Varint).int64(message.leaseMs);
        /* uint32 shard = 7; */
        if (message.shard !== 0)
            writer.tag(7, WireType.Varint).uint32(message.shard);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.RefreshFloatingLimitTask
 */
export const RefreshFloatingLimitTask = new RefreshFloatingLimitTask$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaseTasksResponse$Type extends MessageType<LeaseTasksResponse> {
    constructor() {
        super("silo.v1.LeaseTasksResponse", [
            { no: 1, name: "tasks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Task },
            { no: 2, name: "refresh_tasks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RefreshFloatingLimitTask }
        ]);
    }
    create(value?: PartialMessage<LeaseTasksResponse>): LeaseTasksResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tasks = [];
        message.refreshTasks = [];
        if (value !== undefined)
            reflectionMergePartial<LeaseTasksResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaseTasksResponse): LeaseTasksResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated silo.v1.Task tasks */ 1:
                    message.tasks.push(Task.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated silo.v1.RefreshFloatingLimitTask refresh_tasks */ 2:
                    message.refreshTasks.push(RefreshFloatingLimitTask.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaseTasksResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated silo.v1.Task tasks = 1; */
        for (let i = 0; i < message.tasks.length; i++)
            Task.internalBinaryWrite(message.tasks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated silo.v1.RefreshFloatingLimitTask refresh_tasks = 2; */
        for (let i = 0; i < message.refreshTasks.length; i++)
            RefreshFloatingLimitTask.internalBinaryWrite(message.refreshTasks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.LeaseTasksResponse
 */
export const LeaseTasksResponse = new LeaseTasksResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportOutcomeRequest$Type extends MessageType<ReportOutcomeRequest> {
    constructor() {
        super("silo.v1.ReportOutcomeRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "success", kind: "message", oneof: "outcome", T: () => JsonValueBytes },
            { no: 4, name: "failure", kind: "message", oneof: "outcome", T: () => Failure },
            { no: 6, name: "cancelled", kind: "message", oneof: "outcome", T: () => Cancelled }
        ]);
    }
    create(value?: PartialMessage<ReportOutcomeRequest>): ReportOutcomeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = 0;
        message.taskId = "";
        message.outcome = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ReportOutcomeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportOutcomeRequest): ReportOutcomeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shard */ 1:
                    message.shard = reader.uint32();
                    break;
                case /* string task_id */ 2:
                    message.taskId = reader.string();
                    break;
                case /* optional string tenant */ 5:
                    message.tenant = reader.string();
                    break;
                case /* silo.v1.JsonValueBytes success */ 3:
                    message.outcome = {
                        oneofKind: "success",
                        success: JsonValueBytes.internalBinaryRead(reader, reader.uint32(), options, (message.outcome as any).success)
                    };
                    break;
                case /* silo.v1.Failure failure */ 4:
                    message.outcome = {
                        oneofKind: "failure",
                        failure: Failure.internalBinaryRead(reader, reader.uint32(), options, (message.outcome as any).failure)
                    };
                    break;
                case /* silo.v1.Cancelled cancelled */ 6:
                    message.outcome = {
                        oneofKind: "cancelled",
                        cancelled: Cancelled.internalBinaryRead(reader, reader.uint32(), options, (message.outcome as any).cancelled)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportOutcomeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shard = 1; */
        if (message.shard !== 0)
            writer.tag(1, WireType.Varint).uint32(message.shard);
        /* string task_id = 2; */
        if (message.taskId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.taskId);
        /* silo.v1.JsonValueBytes success = 3; */
        if (message.outcome.oneofKind === "success")
            JsonValueBytes.internalBinaryWrite(message.outcome.success, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.Failure failure = 4; */
        if (message.outcome.oneofKind === "failure")
            Failure.internalBinaryWrite(message.outcome.failure, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional string tenant = 5; */
        if (message.tenant !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.tenant);
        /* silo.v1.Cancelled cancelled = 6; */
        if (message.outcome.oneofKind === "cancelled")
            Cancelled.internalBinaryWrite(message.outcome.cancelled, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ReportOutcomeRequest
 */
export const ReportOutcomeRequest = new ReportOutcomeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Failure$Type extends MessageType<Failure> {
    constructor() {
        super("silo.v1.Failure", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Failure>): Failure {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Failure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Failure): Failure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Failure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.Failure
 */
export const Failure = new Failure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cancelled$Type extends MessageType<Cancelled> {
    constructor() {
        super("silo.v1.Cancelled", []);
    }
    create(value?: PartialMessage<Cancelled>): Cancelled {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Cancelled>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cancelled): Cancelled {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cancelled, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.Cancelled
 */
export const Cancelled = new Cancelled$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportOutcomeResponse$Type extends MessageType<ReportOutcomeResponse> {
    constructor() {
        super("silo.v1.ReportOutcomeResponse", []);
    }
    create(value?: PartialMessage<ReportOutcomeResponse>): ReportOutcomeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReportOutcomeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportOutcomeResponse): ReportOutcomeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportOutcomeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ReportOutcomeResponse
 */
export const ReportOutcomeResponse = new ReportOutcomeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportRefreshOutcomeRequest$Type extends MessageType<ReportRefreshOutcomeRequest> {
    constructor() {
        super("silo.v1.ReportRefreshOutcomeRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "success", kind: "message", oneof: "outcome", T: () => RefreshSuccess },
            { no: 5, name: "failure", kind: "message", oneof: "outcome", T: () => RefreshFailure }
        ]);
    }
    create(value?: PartialMessage<ReportRefreshOutcomeRequest>): ReportRefreshOutcomeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = 0;
        message.taskId = "";
        message.outcome = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ReportRefreshOutcomeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportRefreshOutcomeRequest): ReportRefreshOutcomeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shard */ 1:
                    message.shard = reader.uint32();
                    break;
                case /* string task_id */ 2:
                    message.taskId = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                case /* silo.v1.RefreshSuccess success */ 4:
                    message.outcome = {
                        oneofKind: "success",
                        success: RefreshSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.outcome as any).success)
                    };
                    break;
                case /* silo.v1.RefreshFailure failure */ 5:
                    message.outcome = {
                        oneofKind: "failure",
                        failure: RefreshFailure.internalBinaryRead(reader, reader.uint32(), options, (message.outcome as any).failure)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportRefreshOutcomeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shard = 1; */
        if (message.shard !== 0)
            writer.tag(1, WireType.Varint).uint32(message.shard);
        /* string task_id = 2; */
        if (message.taskId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.taskId);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        /* silo.v1.RefreshSuccess success = 4; */
        if (message.outcome.oneofKind === "success")
            RefreshSuccess.internalBinaryWrite(message.outcome.success, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.RefreshFailure failure = 5; */
        if (message.outcome.oneofKind === "failure")
            RefreshFailure.internalBinaryWrite(message.outcome.failure, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ReportRefreshOutcomeRequest
 */
export const ReportRefreshOutcomeRequest = new ReportRefreshOutcomeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshSuccess$Type extends MessageType<RefreshSuccess> {
    constructor() {
        super("silo.v1.RefreshSuccess", [
            { no: 1, name: "new_max_concurrency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RefreshSuccess>): RefreshSuccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.newMaxConcurrency = 0;
        if (value !== undefined)
            reflectionMergePartial<RefreshSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshSuccess): RefreshSuccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 new_max_concurrency */ 1:
                    message.newMaxConcurrency = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 new_max_concurrency = 1; */
        if (message.newMaxConcurrency !== 0)
            writer.tag(1, WireType.Varint).uint32(message.newMaxConcurrency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.RefreshSuccess
 */
export const RefreshSuccess = new RefreshSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshFailure$Type extends MessageType<RefreshFailure> {
    constructor() {
        super("silo.v1.RefreshFailure", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RefreshFailure>): RefreshFailure {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<RefreshFailure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshFailure): RefreshFailure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshFailure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.RefreshFailure
 */
export const RefreshFailure = new RefreshFailure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportRefreshOutcomeResponse$Type extends MessageType<ReportRefreshOutcomeResponse> {
    constructor() {
        super("silo.v1.ReportRefreshOutcomeResponse", []);
    }
    create(value?: PartialMessage<ReportRefreshOutcomeResponse>): ReportRefreshOutcomeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReportRefreshOutcomeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportRefreshOutcomeResponse): ReportRefreshOutcomeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportRefreshOutcomeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ReportRefreshOutcomeResponse
 */
export const ReportRefreshOutcomeResponse = new ReportRefreshOutcomeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeartbeatRequest$Type extends MessageType<HeartbeatRequest> {
    constructor() {
        super("silo.v1.HeartbeatRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "worker_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HeartbeatRequest>): HeartbeatRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = 0;
        message.workerId = "";
        message.taskId = "";
        if (value !== undefined)
            reflectionMergePartial<HeartbeatRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeartbeatRequest): HeartbeatRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shard */ 1:
                    message.shard = reader.uint32();
                    break;
                case /* string worker_id */ 2:
                    message.workerId = reader.string();
                    break;
                case /* string task_id */ 3:
                    message.taskId = reader.string();
                    break;
                case /* optional string tenant */ 4:
                    message.tenant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeartbeatRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shard = 1; */
        if (message.shard !== 0)
            writer.tag(1, WireType.Varint).uint32(message.shard);
        /* string worker_id = 2; */
        if (message.workerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.workerId);
        /* string task_id = 3; */
        if (message.taskId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.taskId);
        /* optional string tenant = 4; */
        if (message.tenant !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.HeartbeatRequest
 */
export const HeartbeatRequest = new HeartbeatRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeartbeatResponse$Type extends MessageType<HeartbeatResponse> {
    constructor() {
        super("silo.v1.HeartbeatResponse", [
            { no: 1, name: "cancelled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "cancelled_at_ms", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<HeartbeatResponse>): HeartbeatResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cancelled = false;
        if (value !== undefined)
            reflectionMergePartial<HeartbeatResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeartbeatResponse): HeartbeatResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool cancelled */ 1:
                    message.cancelled = reader.bool();
                    break;
                case /* optional int64 cancelled_at_ms */ 2:
                    message.cancelledAtMs = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeartbeatResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool cancelled = 1; */
        if (message.cancelled !== false)
            writer.tag(1, WireType.Varint).bool(message.cancelled);
        /* optional int64 cancelled_at_ms = 2; */
        if (message.cancelledAtMs !== undefined)
            writer.tag(2, WireType.Varint).int64(message.cancelledAtMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.HeartbeatResponse
 */
export const HeartbeatResponse = new HeartbeatResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryRequest$Type extends MessageType<QueryRequest> {
    constructor() {
        super("silo.v1.QueryRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "sql", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryRequest>): QueryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = 0;
        message.sql = "";
        if (value !== undefined)
            reflectionMergePartial<QueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryRequest): QueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shard */ 1:
                    message.shard = reader.uint32();
                    break;
                case /* string sql */ 2:
                    message.sql = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shard = 1; */
        if (message.shard !== 0)
            writer.tag(1, WireType.Varint).uint32(message.shard);
        /* string sql = 2; */
        if (message.sql !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sql);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.QueryRequest
 */
export const QueryRequest = new QueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnInfo$Type extends MessageType<ColumnInfo> {
    constructor() {
        super("silo.v1.ColumnInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ColumnInfo>): ColumnInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.dataType = "";
        if (value !== undefined)
            reflectionMergePartial<ColumnInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ColumnInfo): ColumnInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string data_type */ 2:
                    message.dataType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ColumnInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string data_type = 2; */
        if (message.dataType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dataType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ColumnInfo
 */
export const ColumnInfo = new ColumnInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryResponse$Type extends MessageType<QueryResponse> {
    constructor() {
        super("silo.v1.QueryResponse", [
            { no: 1, name: "columns", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ColumnInfo },
            { no: 2, name: "rows", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => JsonValueBytes },
            { no: 3, name: "row_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<QueryResponse>): QueryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.columns = [];
        message.rows = [];
        message.rowCount = 0;
        if (value !== undefined)
            reflectionMergePartial<QueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryResponse): QueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated silo.v1.ColumnInfo columns */ 1:
                    message.columns.push(ColumnInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated silo.v1.JsonValueBytes rows */ 2:
                    message.rows.push(JsonValueBytes.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 row_count */ 3:
                    message.rowCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated silo.v1.ColumnInfo columns = 1; */
        for (let i = 0; i < message.columns.length; i++)
            ColumnInfo.internalBinaryWrite(message.columns[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated silo.v1.JsonValueBytes rows = 2; */
        for (let i = 0; i < message.rows.length; i++)
            JsonValueBytes.internalBinaryWrite(message.rows[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 row_count = 3; */
        if (message.rowCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.rowCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.QueryResponse
 */
export const QueryResponse = new QueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryArrowRequest$Type extends MessageType<QueryArrowRequest> {
    constructor() {
        super("silo.v1.QueryArrowRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "sql", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryArrowRequest>): QueryArrowRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = 0;
        message.sql = "";
        if (value !== undefined)
            reflectionMergePartial<QueryArrowRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryArrowRequest): QueryArrowRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shard */ 1:
                    message.shard = reader.uint32();
                    break;
                case /* string sql */ 2:
                    message.sql = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryArrowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shard = 1; */
        if (message.shard !== 0)
            writer.tag(1, WireType.Varint).uint32(message.shard);
        /* string sql = 2; */
        if (message.sql !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sql);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.QueryArrowRequest
 */
export const QueryArrowRequest = new QueryArrowRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ArrowIpcMessage$Type extends MessageType<ArrowIpcMessage> {
    constructor() {
        super("silo.v1.ArrowIpcMessage", [
            { no: 1, name: "ipc_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ArrowIpcMessage>): ArrowIpcMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ipcData = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ArrowIpcMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ArrowIpcMessage): ArrowIpcMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes ipc_data */ 1:
                    message.ipcData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ArrowIpcMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes ipc_data = 1; */
        if (message.ipcData.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.ipcData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ArrowIpcMessage
 */
export const ArrowIpcMessage = new ArrowIpcMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetClusterInfoRequest$Type extends MessageType<GetClusterInfoRequest> {
    constructor() {
        super("silo.v1.GetClusterInfoRequest", []);
    }
    create(value?: PartialMessage<GetClusterInfoRequest>): GetClusterInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetClusterInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetClusterInfoRequest): GetClusterInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetClusterInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetClusterInfoRequest
 */
export const GetClusterInfoRequest = new GetClusterInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardOwner$Type extends MessageType<ShardOwner> {
    constructor() {
        super("silo.v1.ShardOwner", [
            { no: 1, name: "shard_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "grpc_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ShardOwner>): ShardOwner {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shardId = 0;
        message.grpcAddr = "";
        message.nodeId = "";
        if (value !== undefined)
            reflectionMergePartial<ShardOwner>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardOwner): ShardOwner {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shard_id */ 1:
                    message.shardId = reader.uint32();
                    break;
                case /* string grpc_addr */ 2:
                    message.grpcAddr = reader.string();
                    break;
                case /* string node_id */ 3:
                    message.nodeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardOwner, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shard_id = 1; */
        if (message.shardId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.shardId);
        /* string grpc_addr = 2; */
        if (message.grpcAddr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.grpcAddr);
        /* string node_id = 3; */
        if (message.nodeId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.nodeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ShardOwner
 */
export const ShardOwner = new ShardOwner$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetClusterInfoResponse$Type extends MessageType<GetClusterInfoResponse> {
    constructor() {
        super("silo.v1.GetClusterInfoResponse", [
            { no: 1, name: "num_shards", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "shard_owners", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ShardOwner },
            { no: 3, name: "this_node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "this_grpc_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetClusterInfoResponse>): GetClusterInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.numShards = 0;
        message.shardOwners = [];
        message.thisNodeId = "";
        message.thisGrpcAddr = "";
        if (value !== undefined)
            reflectionMergePartial<GetClusterInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetClusterInfoResponse): GetClusterInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 num_shards */ 1:
                    message.numShards = reader.uint32();
                    break;
                case /* repeated silo.v1.ShardOwner shard_owners */ 2:
                    message.shardOwners.push(ShardOwner.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string this_node_id */ 3:
                    message.thisNodeId = reader.string();
                    break;
                case /* string this_grpc_addr */ 4:
                    message.thisGrpcAddr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetClusterInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 num_shards = 1; */
        if (message.numShards !== 0)
            writer.tag(1, WireType.Varint).uint32(message.numShards);
        /* repeated silo.v1.ShardOwner shard_owners = 2; */
        for (let i = 0; i < message.shardOwners.length; i++)
            ShardOwner.internalBinaryWrite(message.shardOwners[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string this_node_id = 3; */
        if (message.thisNodeId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.thisNodeId);
        /* string this_grpc_addr = 4; */
        if (message.thisGrpcAddr !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.thisGrpcAddr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetClusterInfoResponse
 */
export const GetClusterInfoResponse = new GetClusterInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetShardsRequest$Type extends MessageType<ResetShardsRequest> {
    constructor() {
        super("silo.v1.ResetShardsRequest", []);
    }
    create(value?: PartialMessage<ResetShardsRequest>): ResetShardsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ResetShardsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetShardsRequest): ResetShardsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResetShardsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ResetShardsRequest
 */
export const ResetShardsRequest = new ResetShardsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetShardsResponse$Type extends MessageType<ResetShardsResponse> {
    constructor() {
        super("silo.v1.ResetShardsResponse", [
            { no: 1, name: "shards_reset", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ResetShardsResponse>): ResetShardsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shardsReset = 0;
        if (value !== undefined)
            reflectionMergePartial<ResetShardsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetShardsResponse): ResetShardsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shards_reset */ 1:
                    message.shardsReset = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResetShardsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shards_reset = 1; */
        if (message.shardsReset !== 0)
            writer.tag(1, WireType.Varint).uint32(message.shardsReset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ResetShardsResponse
 */
export const ResetShardsResponse = new ResetShardsResponse$Type();
/**
 * @generated ServiceType for protobuf service silo.v1.Silo
 */
export const Silo = new ServiceType("silo.v1.Silo", [
    { name: "GetClusterInfo", options: {}, I: GetClusterInfoRequest, O: GetClusterInfoResponse },
    { name: "Enqueue", options: {}, I: EnqueueRequest, O: EnqueueResponse },
    { name: "GetJob", options: {}, I: GetJobRequest, O: GetJobResponse },
    { name: "GetJobResult", options: {}, I: GetJobResultRequest, O: GetJobResultResponse },
    { name: "DeleteJob", options: {}, I: DeleteJobRequest, O: DeleteJobResponse },
    { name: "CancelJob", options: {}, I: CancelJobRequest, O: CancelJobResponse },
    { name: "LeaseTasks", options: {}, I: LeaseTasksRequest, O: LeaseTasksResponse },
    { name: "ReportOutcome", options: {}, I: ReportOutcomeRequest, O: ReportOutcomeResponse },
    { name: "ReportRefreshOutcome", options: {}, I: ReportRefreshOutcomeRequest, O: ReportRefreshOutcomeResponse },
    { name: "Heartbeat", options: {}, I: HeartbeatRequest, O: HeartbeatResponse },
    { name: "Query", options: {}, I: QueryRequest, O: QueryResponse },
    { name: "QueryArrow", serverStreaming: true, options: {}, I: QueryArrowRequest, O: ArrowIpcMessage },
    { name: "ResetShards", options: {}, I: ResetShardsRequest, O: ResetShardsResponse }
]);
