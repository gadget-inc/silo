// @generated by protobuf-ts 2.11.1 with parameter long_type_bigint,generate_dependencies
// @generated from protobuf file "silo.proto" (package "silo.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Container for arbitrary serialized data with support for multiple encoding formats.
 * Currently only MessagePack is supported, but structured as a union for forward compatibility
 * to add new serialization formats in the future (e.g., JSON, Protobuf).
 * Used for job payloads, results, error data, and query response rows.
 *
 * @generated from protobuf message silo.v1.SerializedBytes
 */
export interface SerializedBytes {
    /**
     * @generated from protobuf oneof: encoding
     */
    encoding: {
        oneofKind: "msgpack";
        /**
         * @generated from protobuf field: bytes msgpack = 1
         */
        msgpack: Uint8Array; // Raw MessagePack bytes. Callers should serialize/deserialize using MessagePack.
    } | {
        oneofKind: undefined;
    };
}
/**
 * Configuration for automatic job retry on failure.
 * When a job attempt fails, Silo will automatically retry according to this policy.
 *
 * @generated from protobuf message silo.v1.RetryPolicy
 */
export interface RetryPolicy {
    /**
     * @generated from protobuf field: uint32 retry_count = 1
     */
    retryCount: number; // Maximum number of retry attempts after the initial attempt fails.
    /**
     * @generated from protobuf field: int64 initial_interval_ms = 2
     */
    initialIntervalMs: bigint; // Initial delay in milliseconds before the first retry.
    /**
     * @generated from protobuf field: int64 max_interval_ms = 3
     */
    maxIntervalMs: bigint; // Maximum delay between retries (caps exponential backoff).
    /**
     * @generated from protobuf field: bool randomize_interval = 4
     */
    randomizeInterval: boolean; // If true, adds jitter to retry intervals to prevent thundering herd.
    /**
     * @generated from protobuf field: double backoff_factor = 5
     */
    backoffFactor: number; // Multiplier for exponential backoff (e.g., 2.0 doubles delay each retry).
}
/**
 * Static concurrency limit that restricts how many jobs with the same key can run simultaneously.
 * Jobs sharing the same key will queue up if max_concurrency is reached.
 *
 * @generated from protobuf message silo.v1.ConcurrencyLimit
 */
export interface ConcurrencyLimit {
    /**
     * @generated from protobuf field: string key = 1
     */
    key: string; // Grouping key - jobs with the same key share this limit.
    /**
     * @generated from protobuf field: uint32 max_concurrency = 2
     */
    maxConcurrency: number; // Maximum number of jobs with this key that can run at once.
}
/**
 * Dynamic concurrency limit where the max_concurrency value is computed by workers.
 * Useful when concurrency should be based on external factors like API rate limits.
 * Workers periodically receive refresh tasks to update the limit.
 *
 * @generated from protobuf message silo.v1.FloatingConcurrencyLimit
 */
export interface FloatingConcurrencyLimit {
    /**
     * @generated from protobuf field: string key = 1
     */
    key: string; // Grouping key - jobs with the same key share this limit.
    /**
     * @generated from protobuf field: uint32 default_max_concurrency = 2
     */
    defaultMaxConcurrency: number; // Initial max concurrency used until first worker refresh.
    /**
     * @generated from protobuf field: int64 refresh_interval_ms = 3
     */
    refreshIntervalMs: bigint; // How often workers receive refresh tasks (milliseconds).
    /**
     * @generated from protobuf field: map<string, string> metadata = 4
     */
    metadata: {
        [key: string]: string;
    }; // Arbitrary data passed to workers during refresh (e.g., API credentials).
}
/**
 * Retry policy for when a job is blocked by a rate limit.
 * Configures how long workers should wait before retrying the rate limit check.
 *
 * @generated from protobuf message silo.v1.RateLimitRetryPolicy
 */
export interface RateLimitRetryPolicy {
    /**
     * @generated from protobuf field: int64 initial_backoff_ms = 1
     */
    initialBackoffMs: bigint; // Initial wait time in milliseconds when rate limited.
    /**
     * @generated from protobuf field: int64 max_backoff_ms = 2
     */
    maxBackoffMs: bigint; // Maximum wait time between retries.
    /**
     * @generated from protobuf field: double backoff_multiplier = 3
     */
    backoffMultiplier: number; // Multiplier for exponential backoff (default 2.0).
    /**
     * @generated from protobuf field: uint32 max_retries = 4
     */
    maxRetries: number; // Max retries before failing the job (0 = infinite until reset_time).
}
/**
 * Rate limit backed by the Gubernator distributed rate limiting service.
 * Allows controlling job throughput based on request rates.
 *
 * @generated from protobuf message silo.v1.GubernatorRateLimit
 */
export interface GubernatorRateLimit {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string; // Human-readable name for debugging and metrics.
    /**
     * @generated from protobuf field: string unique_key = 2
     */
    uniqueKey: string; // Unique identifier for this rate limit instance (e.g., user ID).
    /**
     * @generated from protobuf field: int64 limit = 3
     */
    limit: bigint; // Maximum number of requests allowed within the duration.
    /**
     * @generated from protobuf field: int64 duration_ms = 4
     */
    durationMs: bigint; // Time window in milliseconds for the rate limit.
    /**
     * @generated from protobuf field: int32 hits = 5
     */
    hits: number; // Number of hits this job consumes (usually 1).
    /**
     * @generated from protobuf field: silo.v1.GubernatorAlgorithm algorithm = 6
     */
    algorithm: GubernatorAlgorithm; // Algorithm for rate limiting (token bucket or leaky bucket).
    /**
     * @generated from protobuf field: int32 behavior = 7
     */
    behavior: number; // Behavior flags - combine GubernatorBehavior values with OR.
    /**
     * @generated from protobuf field: silo.v1.RateLimitRetryPolicy retry_policy = 8
     */
    retryPolicy?: RateLimitRetryPolicy; // Policy for retrying when rate limited.
}
/**
 * Union type representing any kind of limit that can be applied to a job.
 * Jobs can have multiple limits; all must be satisfied before execution.
 *
 * @generated from protobuf message silo.v1.Limit
 */
export interface Limit {
    /**
     * @generated from protobuf oneof: limit
     */
    limit: {
        oneofKind: "concurrency";
        /**
         * @generated from protobuf field: silo.v1.ConcurrencyLimit concurrency = 1
         */
        concurrency: ConcurrencyLimit; // Static concurrency limit.
    } | {
        oneofKind: "rateLimit";
        /**
         * @generated from protobuf field: silo.v1.GubernatorRateLimit rate_limit = 2
         */
        rateLimit: GubernatorRateLimit; // Gubernator-based rate limit.
    } | {
        oneofKind: "floatingConcurrency";
        /**
         * @generated from protobuf field: silo.v1.FloatingConcurrencyLimit floating_concurrency = 3
         */
        floatingConcurrency: FloatingConcurrencyLimit; // Dynamic worker-computed concurrency limit.
    } | {
        oneofKind: undefined;
    };
}
/**
 * Request to enqueue a new job for processing.
 *
 * @generated from protobuf message silo.v1.EnqueueRequest
 */
export interface EnqueueRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string; // Shard ID (UUID) where the job should be stored.
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string; // Optional job ID. If empty, a random UUID is generated.
    /**
     * @generated from protobuf field: uint32 priority = 3
     */
    priority: number; // Priority from 0-99. Lower is higher priority (0 = highest).
    /**
     * @generated from protobuf field: int64 start_at_ms = 4
     */
    startAtMs: bigint; // Unix timestamp (ms) for future scheduling. 0 = run immediately.
    /**
     * @generated from protobuf field: optional silo.v1.RetryPolicy retry_policy = 5
     */
    retryPolicy?: RetryPolicy; // Retry configuration. If absent, job fails on first error.
    /**
     * @generated from protobuf field: silo.v1.SerializedBytes payload = 6
     */
    payload?: SerializedBytes; // Opaque serialized payload passed to workers.
    /**
     * @generated from protobuf field: repeated silo.v1.Limit limits = 7
     */
    limits: Limit[]; // Ordered list of limits checked before execution.
    /**
     * @generated from protobuf field: optional string tenant = 8
     */
    tenant?: string; // Tenant ID for multi-tenant deployments. Optional.
    /**
     * @generated from protobuf field: map<string, string> metadata = 9
     */
    metadata: {
        [key: string]: string;
    }; // Arbitrary key/value metadata stored with the job.
    /**
     * @generated from protobuf field: string task_group = 10
     */
    taskGroup: string; // Task group for organizing tasks. Required. Tasks are enqueued into this group.
}
/**
 * Response after successfully enqueueing a job.
 *
 * @generated from protobuf message silo.v1.EnqueueResponse
 */
export interface EnqueueResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // The job's ID (either provided or auto-generated).
}
/**
 * Request to retrieve details about a specific job.
 *
 * @generated from protobuf message silo.v1.GetJobRequest
 */
export interface GetJobRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string; // Shard ID (UUID) where the job is stored.
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string; // The job's unique ID.
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string; // Tenant ID if multi-tenancy is enabled.
    /**
     * @generated from protobuf field: bool include_attempts = 4
     */
    includeAttempts: boolean; // If true, include all attempts in the response. Defaults to false.
}
/**
 * A single execution attempt of a job.
 *
 * @generated from protobuf message silo.v1.JobAttempt
 */
export interface JobAttempt {
    /**
     * @generated from protobuf field: string job_id = 1
     */
    jobId: string; // The job's unique ID.
    /**
     * @generated from protobuf field: uint32 attempt_number = 2
     */
    attemptNumber: number; // Which attempt this is (1 = first attempt).
    /**
     * @generated from protobuf field: string task_id = 3
     */
    taskId: string; // Unique task ID for this attempt.
    /**
     * @generated from protobuf field: silo.v1.AttemptStatus status = 4
     */
    status: AttemptStatus; // Current status of the attempt.
    /**
     * @generated from protobuf field: int64 started_at_ms = 5
     */
    startedAtMs: bigint; // Unix timestamp (ms) when attempt started. Present for all attempts.
    /**
     * @generated from protobuf field: optional int64 finished_at_ms = 6
     */
    finishedAtMs?: bigint; // Unix timestamp (ms) when attempt finished. Present if completed.
    /**
     * @generated from protobuf field: optional silo.v1.SerializedBytes result = 7
     */
    result?: SerializedBytes; // Result data if attempt succeeded.
    /**
     * @generated from protobuf field: optional string error_code = 8
     */
    errorCode?: string; // Error code if attempt failed.
    /**
     * @generated from protobuf field: optional silo.v1.SerializedBytes error_data = 9
     */
    errorData?: SerializedBytes; // Error details if attempt failed.
}
/**
 * Full details of a job including its current state.
 *
 * @generated from protobuf message silo.v1.GetJobResponse
 */
export interface GetJobResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // The job's unique ID.
    /**
     * @generated from protobuf field: uint32 priority = 2
     */
    priority: number; // Job priority (0 = highest, 99 = lowest).
    /**
     * @generated from protobuf field: int64 enqueue_time_ms = 3
     */
    enqueueTimeMs: bigint; // Unix timestamp (ms) when job was enqueued.
    /**
     * @generated from protobuf field: silo.v1.SerializedBytes payload = 4
     */
    payload?: SerializedBytes; // The job's payload data.
    /**
     * @generated from protobuf field: optional silo.v1.RetryPolicy retry_policy = 5
     */
    retryPolicy?: RetryPolicy; // Retry policy if configured.
    /**
     * @generated from protobuf field: repeated silo.v1.Limit limits = 6
     */
    limits: Limit[]; // Limits declared on this job.
    /**
     * @generated from protobuf field: map<string, string> metadata = 7
     */
    metadata: {
        [key: string]: string;
    }; // Metadata key/value pairs.
    /**
     * @generated from protobuf field: silo.v1.JobStatus status = 8
     */
    status: JobStatus; // Current job status.
    /**
     * @generated from protobuf field: int64 status_changed_at_ms = 9
     */
    statusChangedAtMs: bigint; // Unix timestamp (ms) of last status change.
    /**
     * @generated from protobuf field: repeated silo.v1.JobAttempt attempts = 10
     */
    attempts: JobAttempt[]; // All attempts for this job. Only populated if include_attempts was true in the request.
    /**
     * @generated from protobuf field: optional int64 next_attempt_starts_after_ms = 11
     */
    nextAttemptStartsAfterMs?: bigint; // Unix timestamp (ms) when the next attempt will start. Present for scheduled jobs, absent for running or terminal jobs.
    /**
     * @generated from protobuf field: string task_group = 12
     */
    taskGroup: string; // Task group this job's tasks are enqueued into.
    /**
     * @generated from protobuf field: optional silo.v1.SerializedBytes result = 13
     */
    result?: SerializedBytes; // Result data from the last attempt, if the job succeeded.
}
/**
 * Request to get the result of a completed job.
 * Only succeeds if the job has reached a terminal state (succeeded, failed, or cancelled).
 *
 * @generated from protobuf message silo.v1.GetJobResultRequest
 */
export interface GetJobResultRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string; // Shard ID (UUID) where the job is stored.
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string; // The job's unique ID.
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string; // Tenant ID if multi-tenancy is enabled.
}
/**
 * Result of a completed job. Check status to determine which result field is populated.
 *
 * @generated from protobuf message silo.v1.GetJobResultResponse
 */
export interface GetJobResultResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // The job's unique ID.
    /**
     * @generated from protobuf field: silo.v1.JobStatus status = 2
     */
    status: JobStatus; // Terminal status: SUCCEEDED, FAILED, or CANCELLED.
    /**
     * @generated from protobuf field: int64 finished_at_ms = 3
     */
    finishedAtMs: bigint; // Unix timestamp (ms) when job reached terminal state.
    /**
     * The result depends on the terminal status.
     *
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "successData";
        /**
         * @generated from protobuf field: silo.v1.SerializedBytes success_data = 4
         */
        successData: SerializedBytes; // Present if status == SUCCEEDED. Contains job result.
    } | {
        oneofKind: "failure";
        /**
         * @generated from protobuf field: silo.v1.JobFailure failure = 5
         */
        failure: JobFailure; // Present if status == FAILED. Contains error details.
    } | {
        oneofKind: "cancelled";
        /**
         * @generated from protobuf field: silo.v1.JobCancelled cancelled = 6
         */
        cancelled: JobCancelled; // Present if status == CANCELLED. Contains cancellation info.
    } | {
        oneofKind: undefined;
    };
}
/**
 * Error information for a failed job.
 *
 * @generated from protobuf message silo.v1.JobFailure
 */
export interface JobFailure {
    /**
     * @generated from protobuf field: string error_code = 1
     */
    errorCode: string; // Application-defined error code.
    /**
     * @generated from protobuf field: silo.v1.SerializedBytes error_data = 2
     */
    errorData?: SerializedBytes; // Serialized error details.
}
/**
 * Information about a cancelled job.
 *
 * @generated from protobuf message silo.v1.JobCancelled
 */
export interface JobCancelled {
    /**
     * @generated from protobuf field: int64 cancelled_at_ms = 1
     */
    cancelledAtMs: bigint; // Unix timestamp (ms) when cancellation was requested.
}
/**
 * Request to permanently delete a job and all its data.
 *
 * @generated from protobuf message silo.v1.DeleteJobRequest
 */
export interface DeleteJobRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string; // Shard ID (UUID) where the job is stored.
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string; // The job's unique ID.
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string; // Tenant ID if multi-tenancy is enabled.
}
/**
 * Response confirming job deletion.
 *
 * @generated from protobuf message silo.v1.DeleteJobResponse
 */
export interface DeleteJobResponse {
}
/**
 * Request to cancel a job. Running jobs will be notified via heartbeat response.
 *
 * @generated from protobuf message silo.v1.CancelJobRequest
 */
export interface CancelJobRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string; // Shard ID (UUID) where the job is stored.
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string; // The job's unique ID.
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string; // Tenant ID if multi-tenancy is enabled.
}
/**
 * Response confirming cancellation was requested.
 *
 * @generated from protobuf message silo.v1.CancelJobResponse
 */
export interface CancelJobResponse {
}
/**
 * Restart a cancelled or failed job, allowing it to be processed again.
 * The job will get a fresh set of retries according to its retry policy.
 *
 * @generated from protobuf message silo.v1.RestartJobRequest
 */
export interface RestartJobRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string;
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string;
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string;
}
/**
 * @generated from protobuf message silo.v1.RestartJobResponse
 */
export interface RestartJobResponse {
}
/**
 * Expedite a future-scheduled job to run immediately.
 * This is useful for dragging forward a job that was scheduled for the future,
 * or for skipping retry backoff delays on a mid-retry job.
 *
 * @generated from protobuf message silo.v1.ExpediteJobRequest
 */
export interface ExpediteJobRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string;
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string;
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string;
}
/**
 * @generated from protobuf message silo.v1.ExpediteJobResponse
 */
export interface ExpediteJobResponse {
}
/**
 * Lease a specific job's task directly, putting it into Running state.
 * This is a test-oriented helper: workers should use LeaseTasks for normal processing.
 * Bypasses concurrency/rate-limit processing and creates a RunAttempt lease directly.
 * Returns FAILED_PRECONDITION if the job is running, terminal, or cancelled.
 * Returns NOT_FOUND if the job doesn't exist.
 *
 * @generated from protobuf message silo.v1.LeaseTaskRequest
 */
export interface LeaseTaskRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string; // Shard ID (UUID) where the job is stored.
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string; // The job's unique ID.
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string; // Tenant ID if multi-tenancy is enabled.
    /**
     * @generated from protobuf field: string worker_id = 4
     */
    workerId: string; // Worker ID to assign the lease to.
}
/**
 * @generated from protobuf message silo.v1.LeaseTaskResponse
 */
export interface LeaseTaskResponse {
    /**
     * @generated from protobuf field: silo.v1.Task task = 1
     */
    task?: Task; // The leased task.
}
/**
 * Lease tasks for processing from this server.
 * By default, leases from all shards this server owns (fair distribution).
 * If shard is specified, filters to only that shard.
 *
 * @generated from protobuf message silo.v1.LeaseTasksRequest
 */
export interface LeaseTasksRequest {
    /**
     * @generated from protobuf field: optional string shard = 1
     */
    shard?: string; // optional filter - if set, only lease from this shard (UUID)
    /**
     * @generated from protobuf field: string worker_id = 2
     */
    workerId: string;
    /**
     * @generated from protobuf field: uint32 max_tasks = 3
     */
    maxTasks: number;
    /**
     * @generated from protobuf field: string task_group = 4
     */
    taskGroup: string; // Required. Task group to poll tasks from.
}
/**
 * A task representing a single job attempt leased to a worker.
 *
 * @generated from protobuf message silo.v1.Task
 */
export interface Task {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // Unique task ID (different from job ID).
    /**
     * @generated from protobuf field: string job_id = 2
     */
    jobId: string; // ID of the job this task belongs to.
    /**
     * @generated from protobuf field: optional string tenant_id = 3
     */
    tenantId?: string; // Tenant ID if multi-tenancy is enabled.
    /**
     * @generated from protobuf field: uint32 attempt_number = 4
     */
    attemptNumber: number; // Which attempt this is (1 = first attempt). Monotonically increasing across restarts.
    /**
     * @generated from protobuf field: uint32 relative_attempt_number = 5
     */
    relativeAttemptNumber: number; // Attempt within current run (1 = first attempt since last restart). Resets on restart.
    /**
     * @generated from protobuf field: bool is_last_attempt = 6
     */
    isLastAttempt: boolean; // True if this is the final attempt (no more retries after this run).
    /**
     * @generated from protobuf field: map<string, string> metadata = 7
     */
    metadata: {
        [key: string]: string;
    }; // Metadata key/value pairs from the job.
    /**
     * @generated from protobuf field: repeated silo.v1.Limit limits = 8
     */
    limits: Limit[]; // Limits declared on this job (concurrency, rate, floating).
    /**
     * @generated from protobuf field: silo.v1.SerializedBytes payload = 9
     */
    payload?: SerializedBytes; // The job's payload for the worker to process.
    /**
     * @generated from protobuf field: uint32 priority = 10
     */
    priority: number; // Job priority (for informational purposes).
    /**
     * @generated from protobuf field: string shard = 11
     */
    shard: string; // Shard ID (UUID) this task came from (needed for reporting outcome).
    /**
     * @generated from protobuf field: string task_group = 12
     */
    taskGroup: string; // Task group this task belongs to.
    /**
     * @generated from protobuf field: int64 lease_ms = 13
     */
    leaseMs: bigint; // How long the lease lasts. Heartbeat before this expires.
}
/**
 * Task for refreshing a floating concurrency limit.
 * Workers compute the new max_concurrency and report back.
 *
 * @generated from protobuf message silo.v1.RefreshFloatingLimitTask
 */
export interface RefreshFloatingLimitTask {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // Unique task ID for this refresh.
    /**
     * @generated from protobuf field: string queue_key = 2
     */
    queueKey: string; // The floating limit key being refreshed.
    /**
     * @generated from protobuf field: uint32 current_max_concurrency = 3
     */
    currentMaxConcurrency: number; // Current max concurrency value.
    /**
     * @generated from protobuf field: int64 last_refreshed_at_ms = 4
     */
    lastRefreshedAtMs: bigint; // Unix timestamp (ms) of last refresh.
    /**
     * @generated from protobuf field: map<string, string> metadata = 5
     */
    metadata: {
        [key: string]: string;
    }; // Metadata from the limit definition.
    /**
     * @generated from protobuf field: int64 lease_ms = 6
     */
    leaseMs: bigint; // How long the lease lasts. Heartbeat before this expires.
    /**
     * @generated from protobuf field: string shard = 7
     */
    shard: string; // Shard ID (UUID) this task came from (needed for reporting outcome).
    /**
     * @generated from protobuf field: string task_group = 8
     */
    taskGroup: string; // Task group this refresh task belongs to.
    /**
     * @generated from protobuf field: optional string tenant_id = 9
     */
    tenantId?: string; // Tenant ID if multi-tenancy is enabled.
}
/**
 * Response containing tasks leased to a worker.
 *
 * @generated from protobuf message silo.v1.LeaseTasksResponse
 */
export interface LeaseTasksResponse {
    /**
     * @generated from protobuf field: repeated silo.v1.Task tasks = 1
     */
    tasks: Task[]; // Job execution tasks.
    /**
     * @generated from protobuf field: repeated silo.v1.RefreshFloatingLimitTask refresh_tasks = 2
     */
    refreshTasks: RefreshFloatingLimitTask[]; // Floating limit refresh tasks.
}
/**
 * Request to report the outcome of a completed task.
 * Note: tenant is determined from the task lease, not from the request.
 *
 * @generated from protobuf message silo.v1.ReportOutcomeRequest
 */
export interface ReportOutcomeRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string; // Shard ID (UUID) the task came from.
    /**
     * @generated from protobuf field: string task_id = 2
     */
    taskId: string; // The task's unique ID.
    /**
     * @generated from protobuf oneof: outcome
     */
    outcome: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: silo.v1.SerializedBytes success = 3
         */
        success: SerializedBytes; // Job succeeded. Contains result data from executing the job.
    } | {
        oneofKind: "failure";
        /**
         * @generated from protobuf field: silo.v1.Failure failure = 4
         */
        failure: Failure; // Job failed. Contains error details.
    } | {
        oneofKind: "cancelled";
        /**
         * @generated from protobuf field: silo.v1.Cancelled cancelled = 6
         */
        cancelled: Cancelled; // Worker acknowledges job was cancelled.
    } | {
        oneofKind: undefined;
    };
}
/**
 * Error details for a failed task.
 *
 * @generated from protobuf message silo.v1.Failure
 */
export interface Failure {
    /**
     * @generated from protobuf field: string code = 1
     */
    code: string; // Application-defined error code.
    /**
     * @generated from protobuf field: silo.v1.SerializedBytes data = 2
     */
    data?: SerializedBytes; // Serialized error details.
}
/**
 * Marker indicating the worker acknowledges the job was cancelled.
 *
 * @generated from protobuf message silo.v1.Cancelled
 */
export interface Cancelled {
}
/**
 * Response confirming outcome was recorded.
 *
 * @generated from protobuf message silo.v1.ReportOutcomeResponse
 */
export interface ReportOutcomeResponse {
}
/**
 * Request to report the outcome of a floating limit refresh task.
 * Note: tenant is determined from the task lease, not from the request.
 *
 * @generated from protobuf message silo.v1.ReportRefreshOutcomeRequest
 */
export interface ReportRefreshOutcomeRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string; // Shard ID (UUID) the task came from.
    /**
     * @generated from protobuf field: string task_id = 2
     */
    taskId: string; // The task's unique ID.
    /**
     * @generated from protobuf oneof: outcome
     */
    outcome: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: silo.v1.RefreshSuccess success = 4
         */
        success: RefreshSuccess; // Refresh succeeded with new max concurrency.
    } | {
        oneofKind: "failure";
        /**
         * @generated from protobuf field: silo.v1.RefreshFailure failure = 5
         */
        failure: RefreshFailure; // Refresh failed.
    } | {
        oneofKind: undefined;
    };
}
/**
 * Successful floating limit refresh with the new computed value.
 *
 * @generated from protobuf message silo.v1.RefreshSuccess
 */
export interface RefreshSuccess {
    /**
     * @generated from protobuf field: uint32 new_max_concurrency = 1
     */
    newMaxConcurrency: number; // New max concurrency computed by the worker.
}
/**
 * Error during floating limit refresh.
 *
 * @generated from protobuf message silo.v1.RefreshFailure
 */
export interface RefreshFailure {
    /**
     * @generated from protobuf field: string code = 1
     */
    code: string; // Error code.
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string; // Human-readable error message.
}
/**
 * Response confirming refresh outcome was recorded.
 *
 * @generated from protobuf message silo.v1.ReportRefreshOutcomeResponse
 */
export interface ReportRefreshOutcomeResponse {
}
/**
 * Request to extend a task lease and check for cancellation.
 * Workers must heartbeat before lease_ms expires to keep the task.
 * Note: tenant is determined from the task lease, not from the request.
 *
 * @generated from protobuf message silo.v1.HeartbeatRequest
 */
export interface HeartbeatRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string; // Shard ID (UUID) the task came from.
    /**
     * @generated from protobuf field: string worker_id = 2
     */
    workerId: string; // Worker ID that holds the lease.
    /**
     * @generated from protobuf field: string task_id = 3
     */
    taskId: string; // The task's unique ID.
}
/**
 * Response indicating if the lease was extended and if the job was cancelled.
 *
 * @generated from protobuf message silo.v1.HeartbeatResponse
 */
export interface HeartbeatResponse {
    /**
     * @generated from protobuf field: bool cancelled = 1
     */
    cancelled: boolean; // True if job was cancelled. Worker should stop and report Cancelled.
    /**
     * @generated from protobuf field: optional int64 cancelled_at_ms = 2
     */
    cancelledAtMs?: bigint; // Unix timestamp (ms) when cancellation was requested, if cancelled.
}
/**
 * @generated from protobuf message silo.v1.QueryNull
 */
export interface QueryNull {
}
/**
 * A single bind parameter value for SQL query placeholders.
 *
 * @generated from protobuf message silo.v1.QueryParameter
 */
export interface QueryParameter {
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "boolValue";
        /**
         * @generated from protobuf field: bool bool_value = 1
         */
        boolValue: boolean;
    } | {
        oneofKind: "int64Value";
        /**
         * @generated from protobuf field: int64 int64_value = 2
         */
        int64Value: bigint;
    } | {
        oneofKind: "uint64Value";
        /**
         * @generated from protobuf field: uint64 uint64_value = 3
         */
        uint64Value: bigint;
    } | {
        oneofKind: "float64Value";
        /**
         * @generated from protobuf field: double float64_value = 4
         */
        float64Value: number;
    } | {
        oneofKind: "stringValue";
        /**
         * @generated from protobuf field: string string_value = 5
         */
        stringValue: string;
    } | {
        oneofKind: "bytesValue";
        /**
         * @generated from protobuf field: bytes bytes_value = 6
         */
        bytesValue: Uint8Array;
    } | {
        oneofKind: "nullValue";
        /**
         * @generated from protobuf field: silo.v1.QueryNull null_value = 7
         */
        nullValue: QueryNull;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Request to execute an arbitrary SQL query against shard data.
 * Useful for ad-hoc inspection and debugging.
 *
 * @generated from protobuf message silo.v1.QueryRequest
 */
export interface QueryRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string; // Shard ID (UUID) to query.
    /**
     * @generated from protobuf field: string sql = 2
     */
    sql: string; // SQL query string.
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string; // Tenant ID to scope results, if multi-tenancy is enabled.
    /**
     * @generated from protobuf field: repeated silo.v1.QueryParameter parameters = 4
     */
    parameters: QueryParameter[]; // Optional SQL bind parameters (`$1`, `$2`, ...).
}
/**
 * Metadata about a column in query results.
 *
 * @generated from protobuf message silo.v1.ColumnInfo
 */
export interface ColumnInfo {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string; // Column name.
    /**
     * @generated from protobuf field: string data_type = 2
     */
    dataType: string; // Arrow/DataFusion type as string (e.g., "Utf8", "Int64").
}
/**
 * Query results with rows as serialized objects.
 *
 * @generated from protobuf message silo.v1.QueryResponse
 */
export interface QueryResponse {
    /**
     * @generated from protobuf field: repeated silo.v1.ColumnInfo columns = 1
     */
    columns: ColumnInfo[]; // Schema information for the result columns.
    /**
     * @generated from protobuf field: repeated silo.v1.SerializedBytes rows = 2
     */
    rows: SerializedBytes[]; // Each row as a serialized object.
    /**
     * @generated from protobuf field: int32 row_count = 3
     */
    rowCount: number; // Total number of rows returned.
}
/**
 * Request to execute SQL query with Arrow IPC streaming response.
 * More efficient than QueryResponse for large result sets.
 *
 * @generated from protobuf message silo.v1.QueryArrowRequest
 */
export interface QueryArrowRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string; // Shard ID (UUID) to query.
    /**
     * @generated from protobuf field: string sql = 2
     */
    sql: string; // SQL query string.
    /**
     * @generated from protobuf field: optional string tenant = 3
     */
    tenant?: string; // Tenant ID to scope results, if multi-tenancy is enabled.
    /**
     * @generated from protobuf field: repeated silo.v1.QueryParameter parameters = 4
     */
    parameters: QueryParameter[]; // Optional SQL bind parameters (`$1`, `$2`, ...).
}
/**
 * Arrow IPC encoded message. Part of a streaming response.
 *
 * @generated from protobuf message silo.v1.ArrowIpcMessage
 */
export interface ArrowIpcMessage {
    /**
     * @generated from protobuf field: bytes ipc_data = 1
     */
    ipcData: Uint8Array; // Arrow IPC stream data. First message is schema, subsequent are record batches.
}
/**
 * Request to get cluster topology for client-side routing.
 *
 * @generated from protobuf message silo.v1.GetClusterInfoRequest
 */
export interface GetClusterInfoRequest {
}
/**
 * Information about which node owns a specific shard.
 *
 * @generated from protobuf message silo.v1.ShardOwner
 */
export interface ShardOwner {
    /**
     * @generated from protobuf field: string shard_id = 1
     */
    shardId: string; // The shard ID (UUID).
    /**
     * @generated from protobuf field: string grpc_addr = 2
     */
    grpcAddr: string; // gRPC address of the node owning this shard.
    /**
     * @generated from protobuf field: string node_id = 3
     */
    nodeId: string; // Unique identifier of the owning node.
    /**
     * @generated from protobuf field: string range_start = 4
     */
    rangeStart: string; // Inclusive start of the tenant_id range owned by this shard.
    /**
     * @generated from protobuf field: string range_end = 5
     */
    rangeEnd: string; // Exclusive end of the tenant_id range owned by this shard.
    /**
     * @generated from protobuf field: optional string placement_ring = 6
     */
    placementRing?: string; // Placement ring this shard belongs to (empty = default ring).
}
/**
 * Information about a cluster member node.
 *
 * @generated from protobuf message silo.v1.ClusterMember
 */
export interface ClusterMember {
    /**
     * @generated from protobuf field: string node_id = 1
     */
    nodeId: string; // Unique identifier of this node.
    /**
     * @generated from protobuf field: string grpc_addr = 2
     */
    grpcAddr: string; // gRPC address of this node.
    /**
     * @generated from protobuf field: repeated string placement_rings = 3
     */
    placementRings: string[]; // Placement rings this node participates in.
}
/**
 * Cluster topology information.
 *
 * @generated from protobuf message silo.v1.GetClusterInfoResponse
 */
export interface GetClusterInfoResponse {
    /**
     * @generated from protobuf field: uint32 num_shards = 1
     */
    numShards: number; // Total number of shards in the cluster.
    /**
     * @generated from protobuf field: repeated silo.v1.ShardOwner shard_owners = 2
     */
    shardOwners: ShardOwner[]; // Mapping of each shard to its owner.
    /**
     * @generated from protobuf field: string this_node_id = 3
     */
    thisNodeId: string; // Node ID of the server responding.
    /**
     * @generated from protobuf field: string this_grpc_addr = 4
     */
    thisGrpcAddr: string; // gRPC address of the server responding.
    /**
     * @generated from protobuf field: repeated silo.v1.ClusterMember members = 5
     */
    members: ClusterMember[]; // All cluster members with their ring participation.
}
/**
 * Request to reset all shards owned by this server.
 * WARNING: Destructive operation. Only available in dev mode.
 *
 * @generated from protobuf message silo.v1.ResetShardsRequest
 */
export interface ResetShardsRequest {
}
/**
 * Response confirming shards were reset.
 *
 * @generated from protobuf message silo.v1.ResetShardsResponse
 */
export interface ResetShardsResponse {
    /**
     * @generated from protobuf field: uint32 shards_reset = 1
     */
    shardsReset: number; // Number of shards that were cleared.
}
/**
 * Request to capture a CPU profile from this node.
 * Used for production debugging and performance analysis.
 *
 * @generated from protobuf message silo.v1.CpuProfileRequest
 */
export interface CpuProfileRequest {
    /**
     * @generated from protobuf field: uint32 duration_seconds = 1
     */
    durationSeconds: number; // How long to profile (1-300 seconds). Default 30.
    /**
     * @generated from protobuf field: uint32 frequency = 2
     */
    frequency: number; // Sampling frequency in Hz (1-1000). Default 100.
}
/**
 * CPU profile data in pprof protobuf format.
 * Can be analyzed with `pprof` or `go tool pprof`.
 *
 * @generated from protobuf message silo.v1.CpuProfileResponse
 */
export interface CpuProfileResponse {
    /**
     * @generated from protobuf field: bytes profile_data = 1
     */
    profileData: Uint8Array; // pprof protobuf bytes (not gzip compressed).
    /**
     * @generated from protobuf field: uint32 duration_seconds = 2
     */
    durationSeconds: number; // Actual duration profiled.
    /**
     * @generated from protobuf field: uint64 samples = 3
     */
    samples: bigint; // Number of samples collected.
}
/**
 * Request to initiate a shard split operation.
 *
 * @generated from protobuf message silo.v1.RequestSplitRequest
 */
export interface RequestSplitRequest {
    /**
     * @generated from protobuf field: string shard_id = 1
     */
    shardId: string; // Shard ID (UUID) of the shard to split.
    /**
     * @generated from protobuf field: string split_point = 2
     */
    splitPoint: string; // Tenant ID where to split the keyspace.
}
/**
 * Response after initiating a shard split.
 *
 * @generated from protobuf message silo.v1.RequestSplitResponse
 */
export interface RequestSplitResponse {
    /**
     * @generated from protobuf field: string left_child_id = 1
     */
    leftChildId: string; // UUID of the left child shard [parent_start, split_point).
    /**
     * @generated from protobuf field: string right_child_id = 2
     */
    rightChildId: string; // UUID of the right child shard [split_point, parent_end).
    /**
     * @generated from protobuf field: string phase = 3
     */
    phase: string; // Current split phase (e.g., "SplitRequested").
}
/**
 * Request to get the status of a shard split operation.
 *
 * @generated from protobuf message silo.v1.GetSplitStatusRequest
 */
export interface GetSplitStatusRequest {
    /**
     * @generated from protobuf field: string shard_id = 1
     */
    shardId: string; // Parent shard ID (UUID) of the split operation.
}
/**
 * Response with the current split status.
 * Returns empty if no split is in progress for the shard.
 *
 * @generated from protobuf message silo.v1.GetSplitStatusResponse
 */
export interface GetSplitStatusResponse {
    /**
     * @generated from protobuf field: bool in_progress = 1
     */
    inProgress: boolean; // True if a split is in progress for this shard.
    /**
     * @generated from protobuf field: string phase = 2
     */
    phase: string; // Current split phase (empty if not in progress).
    /**
     * @generated from protobuf field: string left_child_id = 3
     */
    leftChildId: string; // UUID of the left child shard (empty if not in progress).
    /**
     * @generated from protobuf field: string right_child_id = 4
     */
    rightChildId: string; // UUID of the right child shard (empty if not in progress).
    /**
     * @generated from protobuf field: string split_point = 5
     */
    splitPoint: string; // Tenant ID at which the split occurs (empty if not in progress).
    /**
     * @generated from protobuf field: string initiator_node_id = 6
     */
    initiatorNodeId: string; // Node ID that initiated the split.
    /**
     * @generated from protobuf field: int64 requested_at_ms = 7
     */
    requestedAtMs: bigint; // Unix timestamp (ms) when split was requested.
}
/**
 * Information about a shard owned by a node, including counters and cleanup status.
 *
 * @generated from protobuf message silo.v1.OwnedShardInfo
 */
export interface OwnedShardInfo {
    /**
     * @generated from protobuf field: string shard_id = 1
     */
    shardId: string; // The shard ID (UUID).
    /**
     * @generated from protobuf field: int64 total_jobs = 2
     */
    totalJobs: bigint; // Total number of jobs in the shard (not deleted).
    /**
     * @generated from protobuf field: int64 completed_jobs = 3
     */
    completedJobs: bigint; // Number of jobs in terminal states (Succeeded, Failed, Cancelled).
    /**
     * @generated from protobuf field: string cleanup_status = 4
     */
    cleanupStatus: string; // Cleanup status: "CompactionDone", "CleanupPending", "CleanupRunning", "CleanupDone".
    /**
     * @generated from protobuf field: int64 created_at_ms = 5
     */
    createdAtMs: bigint; // Unix timestamp (ms) when this shard was first created/initialized.
    /**
     * @generated from protobuf field: int64 cleanup_completed_at_ms = 6
     */
    cleanupCompletedAtMs: bigint; // Unix timestamp (ms) when cleanup completed (0 if not applicable or not completed).
}
/**
 * Request to get node information including owned shards with their counters and cleanup status.
 *
 * @generated from protobuf message silo.v1.GetNodeInfoRequest
 */
export interface GetNodeInfoRequest {
}
/**
 * Response with node information and details for all shards owned by this node.
 *
 * @generated from protobuf message silo.v1.GetNodeInfoResponse
 */
export interface GetNodeInfoResponse {
    /**
     * @generated from protobuf field: string node_id = 1
     */
    nodeId: string; // Unique identifier of this node.
    /**
     * @generated from protobuf field: repeated silo.v1.OwnedShardInfo owned_shards = 2
     */
    ownedShards: OwnedShardInfo[]; // Information for each shard owned by this node.
    /**
     * @generated from protobuf field: repeated string placement_rings = 3
     */
    placementRings: string[]; // Placement rings this node participates in.
}
/**
 * Request to configure a shard's placement ring.
 *
 * @generated from protobuf message silo.v1.ConfigureShardRequest
 */
export interface ConfigureShardRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string; // The shard ID (UUID) to configure.
    /**
     * @generated from protobuf field: optional string placement_ring = 2
     */
    placementRing?: string; // The placement ring to assign (empty/null = default ring).
    /**
     * @generated from protobuf field: optional string tenant = 100
     */
    tenant?: string; // Optional tenant ID (for multi-tenant mode).
}
/**
 * Response after configuring a shard's placement ring.
 *
 * @generated from protobuf message silo.v1.ConfigureShardResponse
 */
export interface ConfigureShardResponse {
    /**
     * @generated from protobuf field: string previous_ring = 1
     */
    previousRing: string; // The placement ring before the change (empty = default ring).
    /**
     * @generated from protobuf field: string current_ring = 2
     */
    currentRing: string; // The placement ring after the change (empty = default ring).
}
/**
 * A historical attempt record for job import.
 * All attempts must be in terminal states (no Running).
 *
 * @generated from protobuf message silo.v1.ImportAttempt
 */
export interface ImportAttempt {
    /**
     * @generated from protobuf field: silo.v1.AttemptStatus status = 1
     */
    status: AttemptStatus; // Must be terminal (SUCCEEDED, FAILED, or CANCELLED).
    /**
     * @generated from protobuf field: int64 started_at_ms = 2
     */
    startedAtMs: bigint; // When the attempt started (epoch ms).
    /**
     * @generated from protobuf field: int64 finished_at_ms = 3
     */
    finishedAtMs: bigint; // When the attempt finished (epoch ms).
    /**
     * @generated from protobuf field: optional silo.v1.SerializedBytes result = 4
     */
    result?: SerializedBytes; // Present if succeeded.
    /**
     * @generated from protobuf field: optional string error_code = 5
     */
    errorCode?: string; // Present if failed.
    /**
     * @generated from protobuf field: optional silo.v1.SerializedBytes error_data = 6
     */
    errorData?: SerializedBytes; // Present if failed.
}
/**
 * Request to import a single job from another system.
 * Unlike Enqueue, ImportJob accepts historical attempts and lets Silo take ownership going forward.
 *
 * @generated from protobuf message silo.v1.ImportJobRequest
 */
export interface ImportJobRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string; // Shard ID (UUID) where the job should be stored.
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string; // Required job ID (migration preserves IDs).
    /**
     * @generated from protobuf field: uint32 priority = 3
     */
    priority: number; // Priority from 0-99. Lower is higher priority.
    /**
     * @generated from protobuf field: int64 enqueue_time_ms = 4
     */
    enqueueTimeMs: bigint; // Original enqueue time from source system (0 = now).
    /**
     * @generated from protobuf field: int64 start_at_ms = 5
     */
    startAtMs: bigint; // When the next attempt should start (0 = now, only for non-terminal).
    /**
     * @generated from protobuf field: optional silo.v1.RetryPolicy retry_policy = 6
     */
    retryPolicy?: RetryPolicy; // Retry configuration.
    /**
     * @generated from protobuf field: silo.v1.SerializedBytes payload = 7
     */
    payload?: SerializedBytes; // Opaque serialized payload.
    /**
     * @generated from protobuf field: repeated silo.v1.Limit limits = 8
     */
    limits: Limit[]; // Ordered list of limits.
    /**
     * @generated from protobuf field: optional string tenant = 9
     */
    tenant?: string; // Tenant ID for multi-tenant deployments.
    /**
     * @generated from protobuf field: map<string, string> metadata = 10
     */
    metadata: {
        [key: string]: string;
    }; // Arbitrary key/value metadata.
    /**
     * @generated from protobuf field: string task_group = 11
     */
    taskGroup: string; // Task group for organizing tasks.
    /**
     * @generated from protobuf field: repeated silo.v1.ImportAttempt attempts = 12
     */
    attempts: ImportAttempt[]; // Historical attempts, all terminal.
}
/**
 * Batch request to import multiple jobs.
 *
 * @generated from protobuf message silo.v1.ImportJobsRequest
 */
export interface ImportJobsRequest {
    /**
     * @generated from protobuf field: repeated silo.v1.ImportJobRequest jobs = 1
     */
    jobs: ImportJobRequest[];
}
/**
 * Result of importing a single job.
 *
 * @generated from protobuf message silo.v1.ImportJobResult
 */
export interface ImportJobResult {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // The job's ID.
    /**
     * @generated from protobuf field: bool success = 2
     */
    success: boolean; // Whether the import succeeded.
    /**
     * @generated from protobuf field: optional string error = 3
     */
    error?: string; // Error message if import failed.
    /**
     * @generated from protobuf field: silo.v1.JobStatus status = 4
     */
    status: JobStatus; // The determined status of the imported job.
}
/**
 * Response containing results for each imported job.
 *
 * @generated from protobuf message silo.v1.ImportJobsResponse
 */
export interface ImportJobsResponse {
    /**
     * @generated from protobuf field: repeated silo.v1.ImportJobResult results = 1
     */
    results: ImportJobResult[];
}
/**
 * Request to force-release a shard's ownership lease.
 * Operator escape hatch for permanently lost nodes.
 *
 * @generated from protobuf message silo.v1.ForceReleaseShardRequest
 */
export interface ForceReleaseShardRequest {
    /**
     * @generated from protobuf field: string shard = 1
     */
    shard: string; // The shard ID (UUID) to force-release.
}
/**
 * Response after force-releasing a shard lease.
 *
 * @generated from protobuf message silo.v1.ForceReleaseShardResponse
 */
export interface ForceReleaseShardResponse {
    /**
     * @generated from protobuf field: bool released = 1
     */
    released: boolean; // True if the lease was released.
}
/**
 * Rate limiting algorithm for Gubernator-based limits.
 *
 * @generated from protobuf enum silo.v1.GubernatorAlgorithm
 */
export enum GubernatorAlgorithm {
    /**
     * Token bucket: tokens refill at steady rate, requests consume tokens.
     *
     * @generated from protobuf enum value: GUBERNATOR_ALGORITHM_TOKEN_BUCKET = 0;
     */
    TOKEN_BUCKET = 0,
    /**
     * Leaky bucket: requests processed at fixed rate, excess queued.
     *
     * @generated from protobuf enum value: GUBERNATOR_ALGORITHM_LEAKY_BUCKET = 1;
     */
    LEAKY_BUCKET = 1
}
/**
 * Behavior flags for Gubernator rate limits. Can be combined via bitwise OR.
 *
 * @generated from protobuf enum silo.v1.GubernatorBehavior
 */
export enum GubernatorBehavior {
    /**
     * Default: batch rate limit checks to peers for efficiency.
     *
     * @generated from protobuf enum value: GUBERNATOR_BEHAVIOR_BATCHING = 0;
     */
    BATCHING = 0,
    /**
     * Send each rate limit check immediately (lower latency, higher load).
     *
     * @generated from protobuf enum value: GUBERNATOR_BEHAVIOR_NO_BATCHING = 1;
     */
    NO_BATCHING = 1,
    /**
     * Synchronize rate limit globally across all Gubernator peers.
     *
     * @generated from protobuf enum value: GUBERNATOR_BEHAVIOR_GLOBAL = 2;
     */
    GLOBAL = 2,
    /**
     * Reset duration on calendar boundaries (minute, hour, day).
     *
     * @generated from protobuf enum value: GUBERNATOR_BEHAVIOR_DURATION_IS_GREGORIAN = 4;
     */
    DURATION_IS_GREGORIAN = 4,
    /**
     * Force reset the remaining counter on this request.
     *
     * @generated from protobuf enum value: GUBERNATOR_BEHAVIOR_RESET_REMAINING = 8;
     */
    RESET_REMAINING = 8,
    /**
     * Set remaining to zero on first over-limit event.
     *
     * @generated from protobuf enum value: GUBERNATOR_BEHAVIOR_DRAIN_OVER_LIMIT = 16;
     */
    DRAIN_OVER_LIMIT = 16
}
/**
 * Current state of a job in its lifecycle.
 *
 * @generated from protobuf enum silo.v1.JobStatus
 */
export enum JobStatus {
    /**
     * Job is waiting to be executed (queued or scheduled for future).
     *
     * @generated from protobuf enum value: JOB_STATUS_SCHEDULED = 0;
     */
    SCHEDULED = 0,
    /**
     * Job is currently being processed by a worker.
     *
     * @generated from protobuf enum value: JOB_STATUS_RUNNING = 1;
     */
    RUNNING = 1,
    /**
     * Job completed successfully.
     *
     * @generated from protobuf enum value: JOB_STATUS_SUCCEEDED = 2;
     */
    SUCCEEDED = 2,
    /**
     * Job failed after exhausting all retry attempts.
     *
     * @generated from protobuf enum value: JOB_STATUS_FAILED = 3;
     */
    FAILED = 3,
    /**
     * Job was cancelled before completion.
     *
     * @generated from protobuf enum value: JOB_STATUS_CANCELLED = 4;
     */
    CANCELLED = 4
}
/**
 * Status of a job attempt in its lifecycle.
 *
 * @generated from protobuf enum silo.v1.AttemptStatus
 */
export enum AttemptStatus {
    /**
     * Attempt is currently running.
     *
     * @generated from protobuf enum value: ATTEMPT_STATUS_RUNNING = 0;
     */
    RUNNING = 0,
    /**
     * Attempt completed successfully.
     *
     * @generated from protobuf enum value: ATTEMPT_STATUS_SUCCEEDED = 1;
     */
    SUCCEEDED = 1,
    /**
     * Attempt failed.
     *
     * @generated from protobuf enum value: ATTEMPT_STATUS_FAILED = 2;
     */
    FAILED = 2,
    /**
     * Attempt was cancelled.
     *
     * @generated from protobuf enum value: ATTEMPT_STATUS_CANCELLED = 3;
     */
    CANCELLED = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class SerializedBytes$Type extends MessageType<SerializedBytes> {
    constructor() {
        super("silo.v1.SerializedBytes", [
            { no: 1, name: "msgpack", kind: "scalar", oneof: "encoding", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SerializedBytes>): SerializedBytes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.encoding = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SerializedBytes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SerializedBytes): SerializedBytes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes msgpack */ 1:
                    message.encoding = {
                        oneofKind: "msgpack",
                        msgpack: reader.bytes()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SerializedBytes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes msgpack = 1; */
        if (message.encoding.oneofKind === "msgpack")
            writer.tag(1, WireType.LengthDelimited).bytes(message.encoding.msgpack);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.SerializedBytes
 */
export const SerializedBytes = new SerializedBytes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetryPolicy$Type extends MessageType<RetryPolicy> {
    constructor() {
        super("silo.v1.RetryPolicy", [
            { no: 1, name: "retry_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "initial_interval_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "max_interval_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "randomize_interval", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "backoff_factor", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<RetryPolicy>): RetryPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.retryCount = 0;
        message.initialIntervalMs = 0n;
        message.maxIntervalMs = 0n;
        message.randomizeInterval = false;
        message.backoffFactor = 0;
        if (value !== undefined)
            reflectionMergePartial<RetryPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetryPolicy): RetryPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 retry_count */ 1:
                    message.retryCount = reader.uint32();
                    break;
                case /* int64 initial_interval_ms */ 2:
                    message.initialIntervalMs = reader.int64().toBigInt();
                    break;
                case /* int64 max_interval_ms */ 3:
                    message.maxIntervalMs = reader.int64().toBigInt();
                    break;
                case /* bool randomize_interval */ 4:
                    message.randomizeInterval = reader.bool();
                    break;
                case /* double backoff_factor */ 5:
                    message.backoffFactor = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetryPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 retry_count = 1; */
        if (message.retryCount !== 0)
            writer.tag(1, WireType.Varint).uint32(message.retryCount);
        /* int64 initial_interval_ms = 2; */
        if (message.initialIntervalMs !== 0n)
            writer.tag(2, WireType.Varint).int64(message.initialIntervalMs);
        /* int64 max_interval_ms = 3; */
        if (message.maxIntervalMs !== 0n)
            writer.tag(3, WireType.Varint).int64(message.maxIntervalMs);
        /* bool randomize_interval = 4; */
        if (message.randomizeInterval !== false)
            writer.tag(4, WireType.Varint).bool(message.randomizeInterval);
        /* double backoff_factor = 5; */
        if (message.backoffFactor !== 0)
            writer.tag(5, WireType.Bit64).double(message.backoffFactor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.RetryPolicy
 */
export const RetryPolicy = new RetryPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConcurrencyLimit$Type extends MessageType<ConcurrencyLimit> {
    constructor() {
        super("silo.v1.ConcurrencyLimit", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "max_concurrency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ConcurrencyLimit>): ConcurrencyLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.maxConcurrency = 0;
        if (value !== undefined)
            reflectionMergePartial<ConcurrencyLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConcurrencyLimit): ConcurrencyLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* uint32 max_concurrency */ 2:
                    message.maxConcurrency = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConcurrencyLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* uint32 max_concurrency = 2; */
        if (message.maxConcurrency !== 0)
            writer.tag(2, WireType.Varint).uint32(message.maxConcurrency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ConcurrencyLimit
 */
export const ConcurrencyLimit = new ConcurrencyLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FloatingConcurrencyLimit$Type extends MessageType<FloatingConcurrencyLimit> {
    constructor() {
        super("silo.v1.FloatingConcurrencyLimit", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "default_max_concurrency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "refresh_interval_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<FloatingConcurrencyLimit>): FloatingConcurrencyLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.defaultMaxConcurrency = 0;
        message.refreshIntervalMs = 0n;
        message.metadata = {};
        if (value !== undefined)
            reflectionMergePartial<FloatingConcurrencyLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FloatingConcurrencyLimit): FloatingConcurrencyLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* uint32 default_max_concurrency */ 2:
                    message.defaultMaxConcurrency = reader.uint32();
                    break;
                case /* int64 refresh_interval_ms */ 3:
                    message.refreshIntervalMs = reader.int64().toBigInt();
                    break;
                case /* map<string, string> metadata */ 4:
                    this.binaryReadMap4(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: FloatingConcurrencyLimit["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof FloatingConcurrencyLimit["metadata"] | undefined, val: FloatingConcurrencyLimit["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for silo.v1.FloatingConcurrencyLimit.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: FloatingConcurrencyLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* uint32 default_max_concurrency = 2; */
        if (message.defaultMaxConcurrency !== 0)
            writer.tag(2, WireType.Varint).uint32(message.defaultMaxConcurrency);
        /* int64 refresh_interval_ms = 3; */
        if (message.refreshIntervalMs !== 0n)
            writer.tag(3, WireType.Varint).int64(message.refreshIntervalMs);
        /* map<string, string> metadata = 4; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.FloatingConcurrencyLimit
 */
export const FloatingConcurrencyLimit = new FloatingConcurrencyLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitRetryPolicy$Type extends MessageType<RateLimitRetryPolicy> {
    constructor() {
        super("silo.v1.RateLimitRetryPolicy", [
            { no: 1, name: "initial_backoff_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "max_backoff_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "backoff_multiplier", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "max_retries", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RateLimitRetryPolicy>): RateLimitRetryPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.initialBackoffMs = 0n;
        message.maxBackoffMs = 0n;
        message.backoffMultiplier = 0;
        message.maxRetries = 0;
        if (value !== undefined)
            reflectionMergePartial<RateLimitRetryPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitRetryPolicy): RateLimitRetryPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 initial_backoff_ms */ 1:
                    message.initialBackoffMs = reader.int64().toBigInt();
                    break;
                case /* int64 max_backoff_ms */ 2:
                    message.maxBackoffMs = reader.int64().toBigInt();
                    break;
                case /* double backoff_multiplier */ 3:
                    message.backoffMultiplier = reader.double();
                    break;
                case /* uint32 max_retries */ 4:
                    message.maxRetries = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitRetryPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 initial_backoff_ms = 1; */
        if (message.initialBackoffMs !== 0n)
            writer.tag(1, WireType.Varint).int64(message.initialBackoffMs);
        /* int64 max_backoff_ms = 2; */
        if (message.maxBackoffMs !== 0n)
            writer.tag(2, WireType.Varint).int64(message.maxBackoffMs);
        /* double backoff_multiplier = 3; */
        if (message.backoffMultiplier !== 0)
            writer.tag(3, WireType.Bit64).double(message.backoffMultiplier);
        /* uint32 max_retries = 4; */
        if (message.maxRetries !== 0)
            writer.tag(4, WireType.Varint).uint32(message.maxRetries);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.RateLimitRetryPolicy
 */
export const RateLimitRetryPolicy = new RateLimitRetryPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GubernatorRateLimit$Type extends MessageType<GubernatorRateLimit> {
    constructor() {
        super("silo.v1.GubernatorRateLimit", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "unique_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "limit", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "duration_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "hits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "algorithm", kind: "enum", T: () => ["silo.v1.GubernatorAlgorithm", GubernatorAlgorithm, "GUBERNATOR_ALGORITHM_"] },
            { no: 7, name: "behavior", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "retry_policy", kind: "message", T: () => RateLimitRetryPolicy }
        ]);
    }
    create(value?: PartialMessage<GubernatorRateLimit>): GubernatorRateLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.uniqueKey = "";
        message.limit = 0n;
        message.durationMs = 0n;
        message.hits = 0;
        message.algorithm = 0;
        message.behavior = 0;
        if (value !== undefined)
            reflectionMergePartial<GubernatorRateLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GubernatorRateLimit): GubernatorRateLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string unique_key */ 2:
                    message.uniqueKey = reader.string();
                    break;
                case /* int64 limit */ 3:
                    message.limit = reader.int64().toBigInt();
                    break;
                case /* int64 duration_ms */ 4:
                    message.durationMs = reader.int64().toBigInt();
                    break;
                case /* int32 hits */ 5:
                    message.hits = reader.int32();
                    break;
                case /* silo.v1.GubernatorAlgorithm algorithm */ 6:
                    message.algorithm = reader.int32();
                    break;
                case /* int32 behavior */ 7:
                    message.behavior = reader.int32();
                    break;
                case /* silo.v1.RateLimitRetryPolicy retry_policy */ 8:
                    message.retryPolicy = RateLimitRetryPolicy.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GubernatorRateLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string unique_key = 2; */
        if (message.uniqueKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uniqueKey);
        /* int64 limit = 3; */
        if (message.limit !== 0n)
            writer.tag(3, WireType.Varint).int64(message.limit);
        /* int64 duration_ms = 4; */
        if (message.durationMs !== 0n)
            writer.tag(4, WireType.Varint).int64(message.durationMs);
        /* int32 hits = 5; */
        if (message.hits !== 0)
            writer.tag(5, WireType.Varint).int32(message.hits);
        /* silo.v1.GubernatorAlgorithm algorithm = 6; */
        if (message.algorithm !== 0)
            writer.tag(6, WireType.Varint).int32(message.algorithm);
        /* int32 behavior = 7; */
        if (message.behavior !== 0)
            writer.tag(7, WireType.Varint).int32(message.behavior);
        /* silo.v1.RateLimitRetryPolicy retry_policy = 8; */
        if (message.retryPolicy)
            RateLimitRetryPolicy.internalBinaryWrite(message.retryPolicy, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GubernatorRateLimit
 */
export const GubernatorRateLimit = new GubernatorRateLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Limit$Type extends MessageType<Limit> {
    constructor() {
        super("silo.v1.Limit", [
            { no: 1, name: "concurrency", kind: "message", oneof: "limit", T: () => ConcurrencyLimit },
            { no: 2, name: "rate_limit", kind: "message", oneof: "limit", T: () => GubernatorRateLimit },
            { no: 3, name: "floating_concurrency", kind: "message", oneof: "limit", T: () => FloatingConcurrencyLimit }
        ]);
    }
    create(value?: PartialMessage<Limit>): Limit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.limit = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Limit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Limit): Limit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* silo.v1.ConcurrencyLimit concurrency */ 1:
                    message.limit = {
                        oneofKind: "concurrency",
                        concurrency: ConcurrencyLimit.internalBinaryRead(reader, reader.uint32(), options, (message.limit as any).concurrency)
                    };
                    break;
                case /* silo.v1.GubernatorRateLimit rate_limit */ 2:
                    message.limit = {
                        oneofKind: "rateLimit",
                        rateLimit: GubernatorRateLimit.internalBinaryRead(reader, reader.uint32(), options, (message.limit as any).rateLimit)
                    };
                    break;
                case /* silo.v1.FloatingConcurrencyLimit floating_concurrency */ 3:
                    message.limit = {
                        oneofKind: "floatingConcurrency",
                        floatingConcurrency: FloatingConcurrencyLimit.internalBinaryRead(reader, reader.uint32(), options, (message.limit as any).floatingConcurrency)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Limit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* silo.v1.ConcurrencyLimit concurrency = 1; */
        if (message.limit.oneofKind === "concurrency")
            ConcurrencyLimit.internalBinaryWrite(message.limit.concurrency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.GubernatorRateLimit rate_limit = 2; */
        if (message.limit.oneofKind === "rateLimit")
            GubernatorRateLimit.internalBinaryWrite(message.limit.rateLimit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.FloatingConcurrencyLimit floating_concurrency = 3; */
        if (message.limit.oneofKind === "floatingConcurrency")
            FloatingConcurrencyLimit.internalBinaryWrite(message.limit.floatingConcurrency, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.Limit
 */
export const Limit = new Limit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnqueueRequest$Type extends MessageType<EnqueueRequest> {
    constructor() {
        super("silo.v1.EnqueueRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "priority", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "start_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "retry_policy", kind: "message", T: () => RetryPolicy },
            { no: 6, name: "payload", kind: "message", T: () => SerializedBytes },
            { no: 7, name: "limits", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Limit },
            { no: 8, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 10, name: "task_group", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EnqueueRequest>): EnqueueRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        message.id = "";
        message.priority = 0;
        message.startAtMs = 0n;
        message.limits = [];
        message.metadata = {};
        message.taskGroup = "";
        if (value !== undefined)
            reflectionMergePartial<EnqueueRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnqueueRequest): EnqueueRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* uint32 priority */ 3:
                    message.priority = reader.uint32();
                    break;
                case /* int64 start_at_ms */ 4:
                    message.startAtMs = reader.int64().toBigInt();
                    break;
                case /* optional silo.v1.RetryPolicy retry_policy */ 5:
                    message.retryPolicy = RetryPolicy.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicy);
                    break;
                case /* silo.v1.SerializedBytes payload */ 6:
                    message.payload = SerializedBytes.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                case /* repeated silo.v1.Limit limits */ 7:
                    message.limits.push(Limit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string tenant */ 8:
                    message.tenant = reader.string();
                    break;
                case /* map<string, string> metadata */ 9:
                    this.binaryReadMap9(message.metadata, reader, options);
                    break;
                case /* string task_group */ 10:
                    message.taskGroup = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: EnqueueRequest["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EnqueueRequest["metadata"] | undefined, val: EnqueueRequest["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for silo.v1.EnqueueRequest.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: EnqueueRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* uint32 priority = 3; */
        if (message.priority !== 0)
            writer.tag(3, WireType.Varint).uint32(message.priority);
        /* int64 start_at_ms = 4; */
        if (message.startAtMs !== 0n)
            writer.tag(4, WireType.Varint).int64(message.startAtMs);
        /* optional silo.v1.RetryPolicy retry_policy = 5; */
        if (message.retryPolicy)
            RetryPolicy.internalBinaryWrite(message.retryPolicy, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.SerializedBytes payload = 6; */
        if (message.payload)
            SerializedBytes.internalBinaryWrite(message.payload, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated silo.v1.Limit limits = 7; */
        for (let i = 0; i < message.limits.length; i++)
            Limit.internalBinaryWrite(message.limits[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional string tenant = 8; */
        if (message.tenant !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.tenant);
        /* map<string, string> metadata = 9; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        /* string task_group = 10; */
        if (message.taskGroup !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.taskGroup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.EnqueueRequest
 */
export const EnqueueRequest = new EnqueueRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnqueueResponse$Type extends MessageType<EnqueueResponse> {
    constructor() {
        super("silo.v1.EnqueueResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EnqueueResponse>): EnqueueResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<EnqueueResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnqueueResponse): EnqueueResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnqueueResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.EnqueueResponse
 */
export const EnqueueResponse = new EnqueueResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetJobRequest$Type extends MessageType<GetJobRequest> {
    constructor() {
        super("silo.v1.GetJobRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "include_attempts", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetJobRequest>): GetJobRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        message.id = "";
        message.includeAttempts = false;
        if (value !== undefined)
            reflectionMergePartial<GetJobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJobRequest): GetJobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                case /* bool include_attempts */ 4:
                    message.includeAttempts = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetJobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        /* bool include_attempts = 4; */
        if (message.includeAttempts !== false)
            writer.tag(4, WireType.Varint).bool(message.includeAttempts);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetJobRequest
 */
export const GetJobRequest = new GetJobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobAttempt$Type extends MessageType<JobAttempt> {
    constructor() {
        super("silo.v1.JobAttempt", [
            { no: 1, name: "job_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "attempt_number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "status", kind: "enum", T: () => ["silo.v1.AttemptStatus", AttemptStatus, "ATTEMPT_STATUS_"] },
            { no: 5, name: "started_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "finished_at_ms", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "result", kind: "message", T: () => SerializedBytes },
            { no: 8, name: "error_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "error_data", kind: "message", T: () => SerializedBytes }
        ]);
    }
    create(value?: PartialMessage<JobAttempt>): JobAttempt {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = "";
        message.attemptNumber = 0;
        message.taskId = "";
        message.status = 0;
        message.startedAtMs = 0n;
        if (value !== undefined)
            reflectionMergePartial<JobAttempt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobAttempt): JobAttempt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string job_id */ 1:
                    message.jobId = reader.string();
                    break;
                case /* uint32 attempt_number */ 2:
                    message.attemptNumber = reader.uint32();
                    break;
                case /* string task_id */ 3:
                    message.taskId = reader.string();
                    break;
                case /* silo.v1.AttemptStatus status */ 4:
                    message.status = reader.int32();
                    break;
                case /* int64 started_at_ms */ 5:
                    message.startedAtMs = reader.int64().toBigInt();
                    break;
                case /* optional int64 finished_at_ms */ 6:
                    message.finishedAtMs = reader.int64().toBigInt();
                    break;
                case /* optional silo.v1.SerializedBytes result */ 7:
                    message.result = SerializedBytes.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* optional string error_code */ 8:
                    message.errorCode = reader.string();
                    break;
                case /* optional silo.v1.SerializedBytes error_data */ 9:
                    message.errorData = SerializedBytes.internalBinaryRead(reader, reader.uint32(), options, message.errorData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobAttempt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string job_id = 1; */
        if (message.jobId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.jobId);
        /* uint32 attempt_number = 2; */
        if (message.attemptNumber !== 0)
            writer.tag(2, WireType.Varint).uint32(message.attemptNumber);
        /* string task_id = 3; */
        if (message.taskId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.taskId);
        /* silo.v1.AttemptStatus status = 4; */
        if (message.status !== 0)
            writer.tag(4, WireType.Varint).int32(message.status);
        /* int64 started_at_ms = 5; */
        if (message.startedAtMs !== 0n)
            writer.tag(5, WireType.Varint).int64(message.startedAtMs);
        /* optional int64 finished_at_ms = 6; */
        if (message.finishedAtMs !== undefined)
            writer.tag(6, WireType.Varint).int64(message.finishedAtMs);
        /* optional silo.v1.SerializedBytes result = 7; */
        if (message.result)
            SerializedBytes.internalBinaryWrite(message.result, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional string error_code = 8; */
        if (message.errorCode !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.errorCode);
        /* optional silo.v1.SerializedBytes error_data = 9; */
        if (message.errorData)
            SerializedBytes.internalBinaryWrite(message.errorData, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.JobAttempt
 */
export const JobAttempt = new JobAttempt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetJobResponse$Type extends MessageType<GetJobResponse> {
    constructor() {
        super("silo.v1.GetJobResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "priority", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "enqueue_time_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "payload", kind: "message", T: () => SerializedBytes },
            { no: 5, name: "retry_policy", kind: "message", T: () => RetryPolicy },
            { no: 6, name: "limits", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Limit },
            { no: 7, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 8, name: "status", kind: "enum", T: () => ["silo.v1.JobStatus", JobStatus, "JOB_STATUS_"] },
            { no: 9, name: "status_changed_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "attempts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => JobAttempt },
            { no: 11, name: "next_attempt_starts_after_ms", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "task_group", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "result", kind: "message", T: () => SerializedBytes }
        ]);
    }
    create(value?: PartialMessage<GetJobResponse>): GetJobResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.priority = 0;
        message.enqueueTimeMs = 0n;
        message.limits = [];
        message.metadata = {};
        message.status = 0;
        message.statusChangedAtMs = 0n;
        message.attempts = [];
        message.taskGroup = "";
        if (value !== undefined)
            reflectionMergePartial<GetJobResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJobResponse): GetJobResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* uint32 priority */ 2:
                    message.priority = reader.uint32();
                    break;
                case /* int64 enqueue_time_ms */ 3:
                    message.enqueueTimeMs = reader.int64().toBigInt();
                    break;
                case /* silo.v1.SerializedBytes payload */ 4:
                    message.payload = SerializedBytes.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                case /* optional silo.v1.RetryPolicy retry_policy */ 5:
                    message.retryPolicy = RetryPolicy.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicy);
                    break;
                case /* repeated silo.v1.Limit limits */ 6:
                    message.limits.push(Limit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<string, string> metadata */ 7:
                    this.binaryReadMap7(message.metadata, reader, options);
                    break;
                case /* silo.v1.JobStatus status */ 8:
                    message.status = reader.int32();
                    break;
                case /* int64 status_changed_at_ms */ 9:
                    message.statusChangedAtMs = reader.int64().toBigInt();
                    break;
                case /* repeated silo.v1.JobAttempt attempts */ 10:
                    message.attempts.push(JobAttempt.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int64 next_attempt_starts_after_ms */ 11:
                    message.nextAttemptStartsAfterMs = reader.int64().toBigInt();
                    break;
                case /* string task_group */ 12:
                    message.taskGroup = reader.string();
                    break;
                case /* optional silo.v1.SerializedBytes result */ 13:
                    message.result = SerializedBytes.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: GetJobResponse["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetJobResponse["metadata"] | undefined, val: GetJobResponse["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for silo.v1.GetJobResponse.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: GetJobResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* uint32 priority = 2; */
        if (message.priority !== 0)
            writer.tag(2, WireType.Varint).uint32(message.priority);
        /* int64 enqueue_time_ms = 3; */
        if (message.enqueueTimeMs !== 0n)
            writer.tag(3, WireType.Varint).int64(message.enqueueTimeMs);
        /* silo.v1.SerializedBytes payload = 4; */
        if (message.payload)
            SerializedBytes.internalBinaryWrite(message.payload, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional silo.v1.RetryPolicy retry_policy = 5; */
        if (message.retryPolicy)
            RetryPolicy.internalBinaryWrite(message.retryPolicy, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated silo.v1.Limit limits = 6; */
        for (let i = 0; i < message.limits.length; i++)
            Limit.internalBinaryWrite(message.limits[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> metadata = 7; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        /* silo.v1.JobStatus status = 8; */
        if (message.status !== 0)
            writer.tag(8, WireType.Varint).int32(message.status);
        /* int64 status_changed_at_ms = 9; */
        if (message.statusChangedAtMs !== 0n)
            writer.tag(9, WireType.Varint).int64(message.statusChangedAtMs);
        /* repeated silo.v1.JobAttempt attempts = 10; */
        for (let i = 0; i < message.attempts.length; i++)
            JobAttempt.internalBinaryWrite(message.attempts[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional int64 next_attempt_starts_after_ms = 11; */
        if (message.nextAttemptStartsAfterMs !== undefined)
            writer.tag(11, WireType.Varint).int64(message.nextAttemptStartsAfterMs);
        /* string task_group = 12; */
        if (message.taskGroup !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.taskGroup);
        /* optional silo.v1.SerializedBytes result = 13; */
        if (message.result)
            SerializedBytes.internalBinaryWrite(message.result, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetJobResponse
 */
export const GetJobResponse = new GetJobResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetJobResultRequest$Type extends MessageType<GetJobResultRequest> {
    constructor() {
        super("silo.v1.GetJobResultRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetJobResultRequest>): GetJobResultRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GetJobResultRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJobResultRequest): GetJobResultRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetJobResultRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetJobResultRequest
 */
export const GetJobResultRequest = new GetJobResultRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetJobResultResponse$Type extends MessageType<GetJobResultResponse> {
    constructor() {
        super("silo.v1.GetJobResultResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["silo.v1.JobStatus", JobStatus, "JOB_STATUS_"] },
            { no: 3, name: "finished_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "success_data", kind: "message", oneof: "result", T: () => SerializedBytes },
            { no: 5, name: "failure", kind: "message", oneof: "result", T: () => JobFailure },
            { no: 6, name: "cancelled", kind: "message", oneof: "result", T: () => JobCancelled }
        ]);
    }
    create(value?: PartialMessage<GetJobResultResponse>): GetJobResultResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.status = 0;
        message.finishedAtMs = 0n;
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<GetJobResultResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJobResultResponse): GetJobResultResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* silo.v1.JobStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* int64 finished_at_ms */ 3:
                    message.finishedAtMs = reader.int64().toBigInt();
                    break;
                case /* silo.v1.SerializedBytes success_data */ 4:
                    message.result = {
                        oneofKind: "successData",
                        successData: SerializedBytes.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).successData)
                    };
                    break;
                case /* silo.v1.JobFailure failure */ 5:
                    message.result = {
                        oneofKind: "failure",
                        failure: JobFailure.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).failure)
                    };
                    break;
                case /* silo.v1.JobCancelled cancelled */ 6:
                    message.result = {
                        oneofKind: "cancelled",
                        cancelled: JobCancelled.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).cancelled)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetJobResultResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* silo.v1.JobStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* int64 finished_at_ms = 3; */
        if (message.finishedAtMs !== 0n)
            writer.tag(3, WireType.Varint).int64(message.finishedAtMs);
        /* silo.v1.SerializedBytes success_data = 4; */
        if (message.result.oneofKind === "successData")
            SerializedBytes.internalBinaryWrite(message.result.successData, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.JobFailure failure = 5; */
        if (message.result.oneofKind === "failure")
            JobFailure.internalBinaryWrite(message.result.failure, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.JobCancelled cancelled = 6; */
        if (message.result.oneofKind === "cancelled")
            JobCancelled.internalBinaryWrite(message.result.cancelled, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetJobResultResponse
 */
export const GetJobResultResponse = new GetJobResultResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobFailure$Type extends MessageType<JobFailure> {
    constructor() {
        super("silo.v1.JobFailure", [
            { no: 1, name: "error_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error_data", kind: "message", T: () => SerializedBytes }
        ]);
    }
    create(value?: PartialMessage<JobFailure>): JobFailure {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.errorCode = "";
        if (value !== undefined)
            reflectionMergePartial<JobFailure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobFailure): JobFailure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error_code */ 1:
                    message.errorCode = reader.string();
                    break;
                case /* silo.v1.SerializedBytes error_data */ 2:
                    message.errorData = SerializedBytes.internalBinaryRead(reader, reader.uint32(), options, message.errorData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobFailure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error_code = 1; */
        if (message.errorCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.errorCode);
        /* silo.v1.SerializedBytes error_data = 2; */
        if (message.errorData)
            SerializedBytes.internalBinaryWrite(message.errorData, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.JobFailure
 */
export const JobFailure = new JobFailure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobCancelled$Type extends MessageType<JobCancelled> {
    constructor() {
        super("silo.v1.JobCancelled", [
            { no: 1, name: "cancelled_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<JobCancelled>): JobCancelled {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cancelledAtMs = 0n;
        if (value !== undefined)
            reflectionMergePartial<JobCancelled>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobCancelled): JobCancelled {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 cancelled_at_ms */ 1:
                    message.cancelledAtMs = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobCancelled, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 cancelled_at_ms = 1; */
        if (message.cancelledAtMs !== 0n)
            writer.tag(1, WireType.Varint).int64(message.cancelledAtMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.JobCancelled
 */
export const JobCancelled = new JobCancelled$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteJobRequest$Type extends MessageType<DeleteJobRequest> {
    constructor() {
        super("silo.v1.DeleteJobRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteJobRequest>): DeleteJobRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteJobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteJobRequest): DeleteJobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteJobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.DeleteJobRequest
 */
export const DeleteJobRequest = new DeleteJobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteJobResponse$Type extends MessageType<DeleteJobResponse> {
    constructor() {
        super("silo.v1.DeleteJobResponse", []);
    }
    create(value?: PartialMessage<DeleteJobResponse>): DeleteJobResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteJobResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteJobResponse): DeleteJobResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteJobResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.DeleteJobResponse
 */
export const DeleteJobResponse = new DeleteJobResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelJobRequest$Type extends MessageType<CancelJobRequest> {
    constructor() {
        super("silo.v1.CancelJobRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CancelJobRequest>): CancelJobRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<CancelJobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelJobRequest): CancelJobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelJobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.CancelJobRequest
 */
export const CancelJobRequest = new CancelJobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelJobResponse$Type extends MessageType<CancelJobResponse> {
    constructor() {
        super("silo.v1.CancelJobResponse", []);
    }
    create(value?: PartialMessage<CancelJobResponse>): CancelJobResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CancelJobResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelJobResponse): CancelJobResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelJobResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.CancelJobResponse
 */
export const CancelJobResponse = new CancelJobResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RestartJobRequest$Type extends MessageType<RestartJobRequest> {
    constructor() {
        super("silo.v1.RestartJobRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RestartJobRequest>): RestartJobRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<RestartJobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RestartJobRequest): RestartJobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RestartJobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.RestartJobRequest
 */
export const RestartJobRequest = new RestartJobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RestartJobResponse$Type extends MessageType<RestartJobResponse> {
    constructor() {
        super("silo.v1.RestartJobResponse", []);
    }
    create(value?: PartialMessage<RestartJobResponse>): RestartJobResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RestartJobResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RestartJobResponse): RestartJobResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RestartJobResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.RestartJobResponse
 */
export const RestartJobResponse = new RestartJobResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpediteJobRequest$Type extends MessageType<ExpediteJobRequest> {
    constructor() {
        super("silo.v1.ExpediteJobRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExpediteJobRequest>): ExpediteJobRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<ExpediteJobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpediteJobRequest): ExpediteJobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpediteJobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ExpediteJobRequest
 */
export const ExpediteJobRequest = new ExpediteJobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpediteJobResponse$Type extends MessageType<ExpediteJobResponse> {
    constructor() {
        super("silo.v1.ExpediteJobResponse", []);
    }
    create(value?: PartialMessage<ExpediteJobResponse>): ExpediteJobResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExpediteJobResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpediteJobResponse): ExpediteJobResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpediteJobResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ExpediteJobResponse
 */
export const ExpediteJobResponse = new ExpediteJobResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaseTaskRequest$Type extends MessageType<LeaseTaskRequest> {
    constructor() {
        super("silo.v1.LeaseTaskRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "worker_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LeaseTaskRequest>): LeaseTaskRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        message.id = "";
        message.workerId = "";
        if (value !== undefined)
            reflectionMergePartial<LeaseTaskRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaseTaskRequest): LeaseTaskRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                case /* string worker_id */ 4:
                    message.workerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaseTaskRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        /* string worker_id = 4; */
        if (message.workerId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.workerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.LeaseTaskRequest
 */
export const LeaseTaskRequest = new LeaseTaskRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaseTaskResponse$Type extends MessageType<LeaseTaskResponse> {
    constructor() {
        super("silo.v1.LeaseTaskResponse", [
            { no: 1, name: "task", kind: "message", T: () => Task }
        ]);
    }
    create(value?: PartialMessage<LeaseTaskResponse>): LeaseTaskResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LeaseTaskResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaseTaskResponse): LeaseTaskResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* silo.v1.Task task */ 1:
                    message.task = Task.internalBinaryRead(reader, reader.uint32(), options, message.task);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaseTaskResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* silo.v1.Task task = 1; */
        if (message.task)
            Task.internalBinaryWrite(message.task, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.LeaseTaskResponse
 */
export const LeaseTaskResponse = new LeaseTaskResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaseTasksRequest$Type extends MessageType<LeaseTasksRequest> {
    constructor() {
        super("silo.v1.LeaseTasksRequest", [
            { no: 1, name: "shard", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "worker_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "max_tasks", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "task_group", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LeaseTasksRequest>): LeaseTasksRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerId = "";
        message.maxTasks = 0;
        message.taskGroup = "";
        if (value !== undefined)
            reflectionMergePartial<LeaseTasksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaseTasksRequest): LeaseTasksRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* string worker_id */ 2:
                    message.workerId = reader.string();
                    break;
                case /* uint32 max_tasks */ 3:
                    message.maxTasks = reader.uint32();
                    break;
                case /* string task_group */ 4:
                    message.taskGroup = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaseTasksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string shard = 1; */
        if (message.shard !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* string worker_id = 2; */
        if (message.workerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.workerId);
        /* uint32 max_tasks = 3; */
        if (message.maxTasks !== 0)
            writer.tag(3, WireType.Varint).uint32(message.maxTasks);
        /* string task_group = 4; */
        if (message.taskGroup !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.taskGroup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.LeaseTasksRequest
 */
export const LeaseTasksRequest = new LeaseTasksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Task$Type extends MessageType<Task> {
    constructor() {
        super("silo.v1.Task", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "job_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "attempt_number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "relative_attempt_number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "is_last_attempt", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 8, name: "limits", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Limit },
            { no: 9, name: "payload", kind: "message", T: () => SerializedBytes },
            { no: 10, name: "priority", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "task_group", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "lease_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Task>): Task {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.jobId = "";
        message.attemptNumber = 0;
        message.relativeAttemptNumber = 0;
        message.isLastAttempt = false;
        message.metadata = {};
        message.limits = [];
        message.priority = 0;
        message.shard = "";
        message.taskGroup = "";
        message.leaseMs = 0n;
        if (value !== undefined)
            reflectionMergePartial<Task>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Task): Task {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string job_id */ 2:
                    message.jobId = reader.string();
                    break;
                case /* optional string tenant_id */ 3:
                    message.tenantId = reader.string();
                    break;
                case /* uint32 attempt_number */ 4:
                    message.attemptNumber = reader.uint32();
                    break;
                case /* uint32 relative_attempt_number */ 5:
                    message.relativeAttemptNumber = reader.uint32();
                    break;
                case /* bool is_last_attempt */ 6:
                    message.isLastAttempt = reader.bool();
                    break;
                case /* map<string, string> metadata */ 7:
                    this.binaryReadMap7(message.metadata, reader, options);
                    break;
                case /* repeated silo.v1.Limit limits */ 8:
                    message.limits.push(Limit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* silo.v1.SerializedBytes payload */ 9:
                    message.payload = SerializedBytes.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                case /* uint32 priority */ 10:
                    message.priority = reader.uint32();
                    break;
                case /* string shard */ 11:
                    message.shard = reader.string();
                    break;
                case /* string task_group */ 12:
                    message.taskGroup = reader.string();
                    break;
                case /* int64 lease_ms */ 13:
                    message.leaseMs = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: Task["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Task["metadata"] | undefined, val: Task["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for silo.v1.Task.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Task, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string job_id = 2; */
        if (message.jobId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.jobId);
        /* optional string tenant_id = 3; */
        if (message.tenantId !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenantId);
        /* uint32 attempt_number = 4; */
        if (message.attemptNumber !== 0)
            writer.tag(4, WireType.Varint).uint32(message.attemptNumber);
        /* uint32 relative_attempt_number = 5; */
        if (message.relativeAttemptNumber !== 0)
            writer.tag(5, WireType.Varint).uint32(message.relativeAttemptNumber);
        /* bool is_last_attempt = 6; */
        if (message.isLastAttempt !== false)
            writer.tag(6, WireType.Varint).bool(message.isLastAttempt);
        /* map<string, string> metadata = 7; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        /* repeated silo.v1.Limit limits = 8; */
        for (let i = 0; i < message.limits.length; i++)
            Limit.internalBinaryWrite(message.limits[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.SerializedBytes payload = 9; */
        if (message.payload)
            SerializedBytes.internalBinaryWrite(message.payload, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* uint32 priority = 10; */
        if (message.priority !== 0)
            writer.tag(10, WireType.Varint).uint32(message.priority);
        /* string shard = 11; */
        if (message.shard !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.shard);
        /* string task_group = 12; */
        if (message.taskGroup !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.taskGroup);
        /* int64 lease_ms = 13; */
        if (message.leaseMs !== 0n)
            writer.tag(13, WireType.Varint).int64(message.leaseMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.Task
 */
export const Task = new Task$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshFloatingLimitTask$Type extends MessageType<RefreshFloatingLimitTask> {
    constructor() {
        super("silo.v1.RefreshFloatingLimitTask", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "queue_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "current_max_concurrency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "last_refreshed_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 6, name: "lease_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "task_group", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "tenant_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RefreshFloatingLimitTask>): RefreshFloatingLimitTask {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.queueKey = "";
        message.currentMaxConcurrency = 0;
        message.lastRefreshedAtMs = 0n;
        message.metadata = {};
        message.leaseMs = 0n;
        message.shard = "";
        message.taskGroup = "";
        if (value !== undefined)
            reflectionMergePartial<RefreshFloatingLimitTask>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshFloatingLimitTask): RefreshFloatingLimitTask {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string queue_key */ 2:
                    message.queueKey = reader.string();
                    break;
                case /* uint32 current_max_concurrency */ 3:
                    message.currentMaxConcurrency = reader.uint32();
                    break;
                case /* int64 last_refreshed_at_ms */ 4:
                    message.lastRefreshedAtMs = reader.int64().toBigInt();
                    break;
                case /* map<string, string> metadata */ 5:
                    this.binaryReadMap5(message.metadata, reader, options);
                    break;
                case /* int64 lease_ms */ 6:
                    message.leaseMs = reader.int64().toBigInt();
                    break;
                case /* string shard */ 7:
                    message.shard = reader.string();
                    break;
                case /* string task_group */ 8:
                    message.taskGroup = reader.string();
                    break;
                case /* optional string tenant_id */ 9:
                    message.tenantId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: RefreshFloatingLimitTask["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof RefreshFloatingLimitTask["metadata"] | undefined, val: RefreshFloatingLimitTask["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for silo.v1.RefreshFloatingLimitTask.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: RefreshFloatingLimitTask, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string queue_key = 2; */
        if (message.queueKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.queueKey);
        /* uint32 current_max_concurrency = 3; */
        if (message.currentMaxConcurrency !== 0)
            writer.tag(3, WireType.Varint).uint32(message.currentMaxConcurrency);
        /* int64 last_refreshed_at_ms = 4; */
        if (message.lastRefreshedAtMs !== 0n)
            writer.tag(4, WireType.Varint).int64(message.lastRefreshedAtMs);
        /* map<string, string> metadata = 5; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        /* int64 lease_ms = 6; */
        if (message.leaseMs !== 0n)
            writer.tag(6, WireType.Varint).int64(message.leaseMs);
        /* string shard = 7; */
        if (message.shard !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.shard);
        /* string task_group = 8; */
        if (message.taskGroup !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.taskGroup);
        /* optional string tenant_id = 9; */
        if (message.tenantId !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.tenantId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.RefreshFloatingLimitTask
 */
export const RefreshFloatingLimitTask = new RefreshFloatingLimitTask$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaseTasksResponse$Type extends MessageType<LeaseTasksResponse> {
    constructor() {
        super("silo.v1.LeaseTasksResponse", [
            { no: 1, name: "tasks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Task },
            { no: 2, name: "refresh_tasks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RefreshFloatingLimitTask }
        ]);
    }
    create(value?: PartialMessage<LeaseTasksResponse>): LeaseTasksResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tasks = [];
        message.refreshTasks = [];
        if (value !== undefined)
            reflectionMergePartial<LeaseTasksResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaseTasksResponse): LeaseTasksResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated silo.v1.Task tasks */ 1:
                    message.tasks.push(Task.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated silo.v1.RefreshFloatingLimitTask refresh_tasks */ 2:
                    message.refreshTasks.push(RefreshFloatingLimitTask.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaseTasksResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated silo.v1.Task tasks = 1; */
        for (let i = 0; i < message.tasks.length; i++)
            Task.internalBinaryWrite(message.tasks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated silo.v1.RefreshFloatingLimitTask refresh_tasks = 2; */
        for (let i = 0; i < message.refreshTasks.length; i++)
            RefreshFloatingLimitTask.internalBinaryWrite(message.refreshTasks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.LeaseTasksResponse
 */
export const LeaseTasksResponse = new LeaseTasksResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportOutcomeRequest$Type extends MessageType<ReportOutcomeRequest> {
    constructor() {
        super("silo.v1.ReportOutcomeRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "success", kind: "message", oneof: "outcome", T: () => SerializedBytes },
            { no: 4, name: "failure", kind: "message", oneof: "outcome", T: () => Failure },
            { no: 6, name: "cancelled", kind: "message", oneof: "outcome", T: () => Cancelled }
        ]);
    }
    create(value?: PartialMessage<ReportOutcomeRequest>): ReportOutcomeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        message.taskId = "";
        message.outcome = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ReportOutcomeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportOutcomeRequest): ReportOutcomeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* string task_id */ 2:
                    message.taskId = reader.string();
                    break;
                case /* silo.v1.SerializedBytes success */ 3:
                    message.outcome = {
                        oneofKind: "success",
                        success: SerializedBytes.internalBinaryRead(reader, reader.uint32(), options, (message.outcome as any).success)
                    };
                    break;
                case /* silo.v1.Failure failure */ 4:
                    message.outcome = {
                        oneofKind: "failure",
                        failure: Failure.internalBinaryRead(reader, reader.uint32(), options, (message.outcome as any).failure)
                    };
                    break;
                case /* silo.v1.Cancelled cancelled */ 6:
                    message.outcome = {
                        oneofKind: "cancelled",
                        cancelled: Cancelled.internalBinaryRead(reader, reader.uint32(), options, (message.outcome as any).cancelled)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportOutcomeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* string task_id = 2; */
        if (message.taskId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.taskId);
        /* silo.v1.SerializedBytes success = 3; */
        if (message.outcome.oneofKind === "success")
            SerializedBytes.internalBinaryWrite(message.outcome.success, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.Failure failure = 4; */
        if (message.outcome.oneofKind === "failure")
            Failure.internalBinaryWrite(message.outcome.failure, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.Cancelled cancelled = 6; */
        if (message.outcome.oneofKind === "cancelled")
            Cancelled.internalBinaryWrite(message.outcome.cancelled, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ReportOutcomeRequest
 */
export const ReportOutcomeRequest = new ReportOutcomeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Failure$Type extends MessageType<Failure> {
    constructor() {
        super("silo.v1.Failure", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "message", T: () => SerializedBytes }
        ]);
    }
    create(value?: PartialMessage<Failure>): Failure {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        if (value !== undefined)
            reflectionMergePartial<Failure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Failure): Failure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* silo.v1.SerializedBytes data */ 2:
                    message.data = SerializedBytes.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Failure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* silo.v1.SerializedBytes data = 2; */
        if (message.data)
            SerializedBytes.internalBinaryWrite(message.data, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.Failure
 */
export const Failure = new Failure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cancelled$Type extends MessageType<Cancelled> {
    constructor() {
        super("silo.v1.Cancelled", []);
    }
    create(value?: PartialMessage<Cancelled>): Cancelled {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Cancelled>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cancelled): Cancelled {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cancelled, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.Cancelled
 */
export const Cancelled = new Cancelled$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportOutcomeResponse$Type extends MessageType<ReportOutcomeResponse> {
    constructor() {
        super("silo.v1.ReportOutcomeResponse", []);
    }
    create(value?: PartialMessage<ReportOutcomeResponse>): ReportOutcomeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReportOutcomeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportOutcomeResponse): ReportOutcomeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportOutcomeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ReportOutcomeResponse
 */
export const ReportOutcomeResponse = new ReportOutcomeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportRefreshOutcomeRequest$Type extends MessageType<ReportRefreshOutcomeRequest> {
    constructor() {
        super("silo.v1.ReportRefreshOutcomeRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "success", kind: "message", oneof: "outcome", T: () => RefreshSuccess },
            { no: 5, name: "failure", kind: "message", oneof: "outcome", T: () => RefreshFailure }
        ]);
    }
    create(value?: PartialMessage<ReportRefreshOutcomeRequest>): ReportRefreshOutcomeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        message.taskId = "";
        message.outcome = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ReportRefreshOutcomeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportRefreshOutcomeRequest): ReportRefreshOutcomeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* string task_id */ 2:
                    message.taskId = reader.string();
                    break;
                case /* silo.v1.RefreshSuccess success */ 4:
                    message.outcome = {
                        oneofKind: "success",
                        success: RefreshSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.outcome as any).success)
                    };
                    break;
                case /* silo.v1.RefreshFailure failure */ 5:
                    message.outcome = {
                        oneofKind: "failure",
                        failure: RefreshFailure.internalBinaryRead(reader, reader.uint32(), options, (message.outcome as any).failure)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportRefreshOutcomeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* string task_id = 2; */
        if (message.taskId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.taskId);
        /* silo.v1.RefreshSuccess success = 4; */
        if (message.outcome.oneofKind === "success")
            RefreshSuccess.internalBinaryWrite(message.outcome.success, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.RefreshFailure failure = 5; */
        if (message.outcome.oneofKind === "failure")
            RefreshFailure.internalBinaryWrite(message.outcome.failure, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ReportRefreshOutcomeRequest
 */
export const ReportRefreshOutcomeRequest = new ReportRefreshOutcomeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshSuccess$Type extends MessageType<RefreshSuccess> {
    constructor() {
        super("silo.v1.RefreshSuccess", [
            { no: 1, name: "new_max_concurrency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RefreshSuccess>): RefreshSuccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.newMaxConcurrency = 0;
        if (value !== undefined)
            reflectionMergePartial<RefreshSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshSuccess): RefreshSuccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 new_max_concurrency */ 1:
                    message.newMaxConcurrency = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 new_max_concurrency = 1; */
        if (message.newMaxConcurrency !== 0)
            writer.tag(1, WireType.Varint).uint32(message.newMaxConcurrency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.RefreshSuccess
 */
export const RefreshSuccess = new RefreshSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshFailure$Type extends MessageType<RefreshFailure> {
    constructor() {
        super("silo.v1.RefreshFailure", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RefreshFailure>): RefreshFailure {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<RefreshFailure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshFailure): RefreshFailure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshFailure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.RefreshFailure
 */
export const RefreshFailure = new RefreshFailure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportRefreshOutcomeResponse$Type extends MessageType<ReportRefreshOutcomeResponse> {
    constructor() {
        super("silo.v1.ReportRefreshOutcomeResponse", []);
    }
    create(value?: PartialMessage<ReportRefreshOutcomeResponse>): ReportRefreshOutcomeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReportRefreshOutcomeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportRefreshOutcomeResponse): ReportRefreshOutcomeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportRefreshOutcomeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ReportRefreshOutcomeResponse
 */
export const ReportRefreshOutcomeResponse = new ReportRefreshOutcomeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeartbeatRequest$Type extends MessageType<HeartbeatRequest> {
    constructor() {
        super("silo.v1.HeartbeatRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "worker_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HeartbeatRequest>): HeartbeatRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        message.workerId = "";
        message.taskId = "";
        if (value !== undefined)
            reflectionMergePartial<HeartbeatRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeartbeatRequest): HeartbeatRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* string worker_id */ 2:
                    message.workerId = reader.string();
                    break;
                case /* string task_id */ 3:
                    message.taskId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeartbeatRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* string worker_id = 2; */
        if (message.workerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.workerId);
        /* string task_id = 3; */
        if (message.taskId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.taskId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.HeartbeatRequest
 */
export const HeartbeatRequest = new HeartbeatRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeartbeatResponse$Type extends MessageType<HeartbeatResponse> {
    constructor() {
        super("silo.v1.HeartbeatResponse", [
            { no: 1, name: "cancelled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "cancelled_at_ms", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<HeartbeatResponse>): HeartbeatResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cancelled = false;
        if (value !== undefined)
            reflectionMergePartial<HeartbeatResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeartbeatResponse): HeartbeatResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool cancelled */ 1:
                    message.cancelled = reader.bool();
                    break;
                case /* optional int64 cancelled_at_ms */ 2:
                    message.cancelledAtMs = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeartbeatResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool cancelled = 1; */
        if (message.cancelled !== false)
            writer.tag(1, WireType.Varint).bool(message.cancelled);
        /* optional int64 cancelled_at_ms = 2; */
        if (message.cancelledAtMs !== undefined)
            writer.tag(2, WireType.Varint).int64(message.cancelledAtMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.HeartbeatResponse
 */
export const HeartbeatResponse = new HeartbeatResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryNull$Type extends MessageType<QueryNull> {
    constructor() {
        super("silo.v1.QueryNull", []);
    }
    create(value?: PartialMessage<QueryNull>): QueryNull {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QueryNull>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryNull): QueryNull {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryNull, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.QueryNull
 */
export const QueryNull = new QueryNull$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryParameter$Type extends MessageType<QueryParameter> {
    constructor() {
        super("silo.v1.QueryParameter", [
            { no: 1, name: "bool_value", kind: "scalar", oneof: "value", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "int64_value", kind: "scalar", oneof: "value", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "uint64_value", kind: "scalar", oneof: "value", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "float64_value", kind: "scalar", oneof: "value", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "string_value", kind: "scalar", oneof: "value", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "bytes_value", kind: "scalar", oneof: "value", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "null_value", kind: "message", oneof: "value", T: () => QueryNull }
        ]);
    }
    create(value?: PartialMessage<QueryParameter>): QueryParameter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<QueryParameter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryParameter): QueryParameter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool bool_value */ 1:
                    message.value = {
                        oneofKind: "boolValue",
                        boolValue: reader.bool()
                    };
                    break;
                case /* int64 int64_value */ 2:
                    message.value = {
                        oneofKind: "int64Value",
                        int64Value: reader.int64().toBigInt()
                    };
                    break;
                case /* uint64 uint64_value */ 3:
                    message.value = {
                        oneofKind: "uint64Value",
                        uint64Value: reader.uint64().toBigInt()
                    };
                    break;
                case /* double float64_value */ 4:
                    message.value = {
                        oneofKind: "float64Value",
                        float64Value: reader.double()
                    };
                    break;
                case /* string string_value */ 5:
                    message.value = {
                        oneofKind: "stringValue",
                        stringValue: reader.string()
                    };
                    break;
                case /* bytes bytes_value */ 6:
                    message.value = {
                        oneofKind: "bytesValue",
                        bytesValue: reader.bytes()
                    };
                    break;
                case /* silo.v1.QueryNull null_value */ 7:
                    message.value = {
                        oneofKind: "nullValue",
                        nullValue: QueryNull.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).nullValue)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryParameter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool bool_value = 1; */
        if (message.value.oneofKind === "boolValue")
            writer.tag(1, WireType.Varint).bool(message.value.boolValue);
        /* int64 int64_value = 2; */
        if (message.value.oneofKind === "int64Value")
            writer.tag(2, WireType.Varint).int64(message.value.int64Value);
        /* uint64 uint64_value = 3; */
        if (message.value.oneofKind === "uint64Value")
            writer.tag(3, WireType.Varint).uint64(message.value.uint64Value);
        /* double float64_value = 4; */
        if (message.value.oneofKind === "float64Value")
            writer.tag(4, WireType.Bit64).double(message.value.float64Value);
        /* string string_value = 5; */
        if (message.value.oneofKind === "stringValue")
            writer.tag(5, WireType.LengthDelimited).string(message.value.stringValue);
        /* bytes bytes_value = 6; */
        if (message.value.oneofKind === "bytesValue")
            writer.tag(6, WireType.LengthDelimited).bytes(message.value.bytesValue);
        /* silo.v1.QueryNull null_value = 7; */
        if (message.value.oneofKind === "nullValue")
            QueryNull.internalBinaryWrite(message.value.nullValue, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.QueryParameter
 */
export const QueryParameter = new QueryParameter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryRequest$Type extends MessageType<QueryRequest> {
    constructor() {
        super("silo.v1.QueryRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sql", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "parameters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => QueryParameter }
        ]);
    }
    create(value?: PartialMessage<QueryRequest>): QueryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        message.sql = "";
        message.parameters = [];
        if (value !== undefined)
            reflectionMergePartial<QueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryRequest): QueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* string sql */ 2:
                    message.sql = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                case /* repeated silo.v1.QueryParameter parameters */ 4:
                    message.parameters.push(QueryParameter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* string sql = 2; */
        if (message.sql !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sql);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        /* repeated silo.v1.QueryParameter parameters = 4; */
        for (let i = 0; i < message.parameters.length; i++)
            QueryParameter.internalBinaryWrite(message.parameters[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.QueryRequest
 */
export const QueryRequest = new QueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnInfo$Type extends MessageType<ColumnInfo> {
    constructor() {
        super("silo.v1.ColumnInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ColumnInfo>): ColumnInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.dataType = "";
        if (value !== undefined)
            reflectionMergePartial<ColumnInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ColumnInfo): ColumnInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string data_type */ 2:
                    message.dataType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ColumnInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string data_type = 2; */
        if (message.dataType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dataType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ColumnInfo
 */
export const ColumnInfo = new ColumnInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryResponse$Type extends MessageType<QueryResponse> {
    constructor() {
        super("silo.v1.QueryResponse", [
            { no: 1, name: "columns", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ColumnInfo },
            { no: 2, name: "rows", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SerializedBytes },
            { no: 3, name: "row_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<QueryResponse>): QueryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.columns = [];
        message.rows = [];
        message.rowCount = 0;
        if (value !== undefined)
            reflectionMergePartial<QueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryResponse): QueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated silo.v1.ColumnInfo columns */ 1:
                    message.columns.push(ColumnInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated silo.v1.SerializedBytes rows */ 2:
                    message.rows.push(SerializedBytes.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 row_count */ 3:
                    message.rowCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated silo.v1.ColumnInfo columns = 1; */
        for (let i = 0; i < message.columns.length; i++)
            ColumnInfo.internalBinaryWrite(message.columns[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated silo.v1.SerializedBytes rows = 2; */
        for (let i = 0; i < message.rows.length; i++)
            SerializedBytes.internalBinaryWrite(message.rows[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 row_count = 3; */
        if (message.rowCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.rowCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.QueryResponse
 */
export const QueryResponse = new QueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryArrowRequest$Type extends MessageType<QueryArrowRequest> {
    constructor() {
        super("silo.v1.QueryArrowRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sql", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "parameters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => QueryParameter }
        ]);
    }
    create(value?: PartialMessage<QueryArrowRequest>): QueryArrowRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        message.sql = "";
        message.parameters = [];
        if (value !== undefined)
            reflectionMergePartial<QueryArrowRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryArrowRequest): QueryArrowRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* string sql */ 2:
                    message.sql = reader.string();
                    break;
                case /* optional string tenant */ 3:
                    message.tenant = reader.string();
                    break;
                case /* repeated silo.v1.QueryParameter parameters */ 4:
                    message.parameters.push(QueryParameter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryArrowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* string sql = 2; */
        if (message.sql !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sql);
        /* optional string tenant = 3; */
        if (message.tenant !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tenant);
        /* repeated silo.v1.QueryParameter parameters = 4; */
        for (let i = 0; i < message.parameters.length; i++)
            QueryParameter.internalBinaryWrite(message.parameters[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.QueryArrowRequest
 */
export const QueryArrowRequest = new QueryArrowRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ArrowIpcMessage$Type extends MessageType<ArrowIpcMessage> {
    constructor() {
        super("silo.v1.ArrowIpcMessage", [
            { no: 1, name: "ipc_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ArrowIpcMessage>): ArrowIpcMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ipcData = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ArrowIpcMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ArrowIpcMessage): ArrowIpcMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes ipc_data */ 1:
                    message.ipcData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ArrowIpcMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes ipc_data = 1; */
        if (message.ipcData.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.ipcData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ArrowIpcMessage
 */
export const ArrowIpcMessage = new ArrowIpcMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetClusterInfoRequest$Type extends MessageType<GetClusterInfoRequest> {
    constructor() {
        super("silo.v1.GetClusterInfoRequest", []);
    }
    create(value?: PartialMessage<GetClusterInfoRequest>): GetClusterInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetClusterInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetClusterInfoRequest): GetClusterInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetClusterInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetClusterInfoRequest
 */
export const GetClusterInfoRequest = new GetClusterInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardOwner$Type extends MessageType<ShardOwner> {
    constructor() {
        super("silo.v1.ShardOwner", [
            { no: 1, name: "shard_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "grpc_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "range_start", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "range_end", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "placement_ring", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ShardOwner>): ShardOwner {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shardId = "";
        message.grpcAddr = "";
        message.nodeId = "";
        message.rangeStart = "";
        message.rangeEnd = "";
        if (value !== undefined)
            reflectionMergePartial<ShardOwner>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardOwner): ShardOwner {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard_id */ 1:
                    message.shardId = reader.string();
                    break;
                case /* string grpc_addr */ 2:
                    message.grpcAddr = reader.string();
                    break;
                case /* string node_id */ 3:
                    message.nodeId = reader.string();
                    break;
                case /* string range_start */ 4:
                    message.rangeStart = reader.string();
                    break;
                case /* string range_end */ 5:
                    message.rangeEnd = reader.string();
                    break;
                case /* optional string placement_ring */ 6:
                    message.placementRing = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardOwner, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard_id = 1; */
        if (message.shardId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shardId);
        /* string grpc_addr = 2; */
        if (message.grpcAddr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.grpcAddr);
        /* string node_id = 3; */
        if (message.nodeId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.nodeId);
        /* string range_start = 4; */
        if (message.rangeStart !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.rangeStart);
        /* string range_end = 5; */
        if (message.rangeEnd !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.rangeEnd);
        /* optional string placement_ring = 6; */
        if (message.placementRing !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.placementRing);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ShardOwner
 */
export const ShardOwner = new ShardOwner$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterMember$Type extends MessageType<ClusterMember> {
    constructor() {
        super("silo.v1.ClusterMember", [
            { no: 1, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "grpc_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "placement_rings", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ClusterMember>): ClusterMember {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nodeId = "";
        message.grpcAddr = "";
        message.placementRings = [];
        if (value !== undefined)
            reflectionMergePartial<ClusterMember>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterMember): ClusterMember {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string node_id */ 1:
                    message.nodeId = reader.string();
                    break;
                case /* string grpc_addr */ 2:
                    message.grpcAddr = reader.string();
                    break;
                case /* repeated string placement_rings */ 3:
                    message.placementRings.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterMember, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string node_id = 1; */
        if (message.nodeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
        /* string grpc_addr = 2; */
        if (message.grpcAddr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.grpcAddr);
        /* repeated string placement_rings = 3; */
        for (let i = 0; i < message.placementRings.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.placementRings[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ClusterMember
 */
export const ClusterMember = new ClusterMember$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetClusterInfoResponse$Type extends MessageType<GetClusterInfoResponse> {
    constructor() {
        super("silo.v1.GetClusterInfoResponse", [
            { no: 1, name: "num_shards", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "shard_owners", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ShardOwner },
            { no: 3, name: "this_node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "this_grpc_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "members", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ClusterMember }
        ]);
    }
    create(value?: PartialMessage<GetClusterInfoResponse>): GetClusterInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.numShards = 0;
        message.shardOwners = [];
        message.thisNodeId = "";
        message.thisGrpcAddr = "";
        message.members = [];
        if (value !== undefined)
            reflectionMergePartial<GetClusterInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetClusterInfoResponse): GetClusterInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 num_shards */ 1:
                    message.numShards = reader.uint32();
                    break;
                case /* repeated silo.v1.ShardOwner shard_owners */ 2:
                    message.shardOwners.push(ShardOwner.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string this_node_id */ 3:
                    message.thisNodeId = reader.string();
                    break;
                case /* string this_grpc_addr */ 4:
                    message.thisGrpcAddr = reader.string();
                    break;
                case /* repeated silo.v1.ClusterMember members */ 5:
                    message.members.push(ClusterMember.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetClusterInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 num_shards = 1; */
        if (message.numShards !== 0)
            writer.tag(1, WireType.Varint).uint32(message.numShards);
        /* repeated silo.v1.ShardOwner shard_owners = 2; */
        for (let i = 0; i < message.shardOwners.length; i++)
            ShardOwner.internalBinaryWrite(message.shardOwners[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string this_node_id = 3; */
        if (message.thisNodeId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.thisNodeId);
        /* string this_grpc_addr = 4; */
        if (message.thisGrpcAddr !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.thisGrpcAddr);
        /* repeated silo.v1.ClusterMember members = 5; */
        for (let i = 0; i < message.members.length; i++)
            ClusterMember.internalBinaryWrite(message.members[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetClusterInfoResponse
 */
export const GetClusterInfoResponse = new GetClusterInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetShardsRequest$Type extends MessageType<ResetShardsRequest> {
    constructor() {
        super("silo.v1.ResetShardsRequest", []);
    }
    create(value?: PartialMessage<ResetShardsRequest>): ResetShardsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ResetShardsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetShardsRequest): ResetShardsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResetShardsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ResetShardsRequest
 */
export const ResetShardsRequest = new ResetShardsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetShardsResponse$Type extends MessageType<ResetShardsResponse> {
    constructor() {
        super("silo.v1.ResetShardsResponse", [
            { no: 1, name: "shards_reset", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ResetShardsResponse>): ResetShardsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shardsReset = 0;
        if (value !== undefined)
            reflectionMergePartial<ResetShardsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetShardsResponse): ResetShardsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shards_reset */ 1:
                    message.shardsReset = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResetShardsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shards_reset = 1; */
        if (message.shardsReset !== 0)
            writer.tag(1, WireType.Varint).uint32(message.shardsReset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ResetShardsResponse
 */
export const ResetShardsResponse = new ResetShardsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CpuProfileRequest$Type extends MessageType<CpuProfileRequest> {
    constructor() {
        super("silo.v1.CpuProfileRequest", [
            { no: 1, name: "duration_seconds", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "frequency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CpuProfileRequest>): CpuProfileRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.durationSeconds = 0;
        message.frequency = 0;
        if (value !== undefined)
            reflectionMergePartial<CpuProfileRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CpuProfileRequest): CpuProfileRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 duration_seconds */ 1:
                    message.durationSeconds = reader.uint32();
                    break;
                case /* uint32 frequency */ 2:
                    message.frequency = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CpuProfileRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 duration_seconds = 1; */
        if (message.durationSeconds !== 0)
            writer.tag(1, WireType.Varint).uint32(message.durationSeconds);
        /* uint32 frequency = 2; */
        if (message.frequency !== 0)
            writer.tag(2, WireType.Varint).uint32(message.frequency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.CpuProfileRequest
 */
export const CpuProfileRequest = new CpuProfileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CpuProfileResponse$Type extends MessageType<CpuProfileResponse> {
    constructor() {
        super("silo.v1.CpuProfileResponse", [
            { no: 1, name: "profile_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "duration_seconds", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "samples", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CpuProfileResponse>): CpuProfileResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.profileData = new Uint8Array(0);
        message.durationSeconds = 0;
        message.samples = 0n;
        if (value !== undefined)
            reflectionMergePartial<CpuProfileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CpuProfileResponse): CpuProfileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes profile_data */ 1:
                    message.profileData = reader.bytes();
                    break;
                case /* uint32 duration_seconds */ 2:
                    message.durationSeconds = reader.uint32();
                    break;
                case /* uint64 samples */ 3:
                    message.samples = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CpuProfileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes profile_data = 1; */
        if (message.profileData.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.profileData);
        /* uint32 duration_seconds = 2; */
        if (message.durationSeconds !== 0)
            writer.tag(2, WireType.Varint).uint32(message.durationSeconds);
        /* uint64 samples = 3; */
        if (message.samples !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.samples);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.CpuProfileResponse
 */
export const CpuProfileResponse = new CpuProfileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestSplitRequest$Type extends MessageType<RequestSplitRequest> {
    constructor() {
        super("silo.v1.RequestSplitRequest", [
            { no: 1, name: "shard_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "split_point", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestSplitRequest>): RequestSplitRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shardId = "";
        message.splitPoint = "";
        if (value !== undefined)
            reflectionMergePartial<RequestSplitRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestSplitRequest): RequestSplitRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard_id */ 1:
                    message.shardId = reader.string();
                    break;
                case /* string split_point */ 2:
                    message.splitPoint = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestSplitRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard_id = 1; */
        if (message.shardId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shardId);
        /* string split_point = 2; */
        if (message.splitPoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.splitPoint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.RequestSplitRequest
 */
export const RequestSplitRequest = new RequestSplitRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestSplitResponse$Type extends MessageType<RequestSplitResponse> {
    constructor() {
        super("silo.v1.RequestSplitResponse", [
            { no: 1, name: "left_child_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "right_child_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "phase", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestSplitResponse>): RequestSplitResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.leftChildId = "";
        message.rightChildId = "";
        message.phase = "";
        if (value !== undefined)
            reflectionMergePartial<RequestSplitResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestSplitResponse): RequestSplitResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string left_child_id */ 1:
                    message.leftChildId = reader.string();
                    break;
                case /* string right_child_id */ 2:
                    message.rightChildId = reader.string();
                    break;
                case /* string phase */ 3:
                    message.phase = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestSplitResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string left_child_id = 1; */
        if (message.leftChildId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.leftChildId);
        /* string right_child_id = 2; */
        if (message.rightChildId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.rightChildId);
        /* string phase = 3; */
        if (message.phase !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.phase);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.RequestSplitResponse
 */
export const RequestSplitResponse = new RequestSplitResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSplitStatusRequest$Type extends MessageType<GetSplitStatusRequest> {
    constructor() {
        super("silo.v1.GetSplitStatusRequest", [
            { no: 1, name: "shard_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSplitStatusRequest>): GetSplitStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shardId = "";
        if (value !== undefined)
            reflectionMergePartial<GetSplitStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSplitStatusRequest): GetSplitStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard_id */ 1:
                    message.shardId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSplitStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard_id = 1; */
        if (message.shardId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shardId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetSplitStatusRequest
 */
export const GetSplitStatusRequest = new GetSplitStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSplitStatusResponse$Type extends MessageType<GetSplitStatusResponse> {
    constructor() {
        super("silo.v1.GetSplitStatusResponse", [
            { no: 1, name: "in_progress", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "phase", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "left_child_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "right_child_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "split_point", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "initiator_node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "requested_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetSplitStatusResponse>): GetSplitStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inProgress = false;
        message.phase = "";
        message.leftChildId = "";
        message.rightChildId = "";
        message.splitPoint = "";
        message.initiatorNodeId = "";
        message.requestedAtMs = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetSplitStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSplitStatusResponse): GetSplitStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool in_progress */ 1:
                    message.inProgress = reader.bool();
                    break;
                case /* string phase */ 2:
                    message.phase = reader.string();
                    break;
                case /* string left_child_id */ 3:
                    message.leftChildId = reader.string();
                    break;
                case /* string right_child_id */ 4:
                    message.rightChildId = reader.string();
                    break;
                case /* string split_point */ 5:
                    message.splitPoint = reader.string();
                    break;
                case /* string initiator_node_id */ 6:
                    message.initiatorNodeId = reader.string();
                    break;
                case /* int64 requested_at_ms */ 7:
                    message.requestedAtMs = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSplitStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool in_progress = 1; */
        if (message.inProgress !== false)
            writer.tag(1, WireType.Varint).bool(message.inProgress);
        /* string phase = 2; */
        if (message.phase !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.phase);
        /* string left_child_id = 3; */
        if (message.leftChildId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.leftChildId);
        /* string right_child_id = 4; */
        if (message.rightChildId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.rightChildId);
        /* string split_point = 5; */
        if (message.splitPoint !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.splitPoint);
        /* string initiator_node_id = 6; */
        if (message.initiatorNodeId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.initiatorNodeId);
        /* int64 requested_at_ms = 7; */
        if (message.requestedAtMs !== 0n)
            writer.tag(7, WireType.Varint).int64(message.requestedAtMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetSplitStatusResponse
 */
export const GetSplitStatusResponse = new GetSplitStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OwnedShardInfo$Type extends MessageType<OwnedShardInfo> {
    constructor() {
        super("silo.v1.OwnedShardInfo", [
            { no: 1, name: "shard_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "total_jobs", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "completed_jobs", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "cleanup_status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "created_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "cleanup_completed_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<OwnedShardInfo>): OwnedShardInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shardId = "";
        message.totalJobs = 0n;
        message.completedJobs = 0n;
        message.cleanupStatus = "";
        message.createdAtMs = 0n;
        message.cleanupCompletedAtMs = 0n;
        if (value !== undefined)
            reflectionMergePartial<OwnedShardInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OwnedShardInfo): OwnedShardInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard_id */ 1:
                    message.shardId = reader.string();
                    break;
                case /* int64 total_jobs */ 2:
                    message.totalJobs = reader.int64().toBigInt();
                    break;
                case /* int64 completed_jobs */ 3:
                    message.completedJobs = reader.int64().toBigInt();
                    break;
                case /* string cleanup_status */ 4:
                    message.cleanupStatus = reader.string();
                    break;
                case /* int64 created_at_ms */ 5:
                    message.createdAtMs = reader.int64().toBigInt();
                    break;
                case /* int64 cleanup_completed_at_ms */ 6:
                    message.cleanupCompletedAtMs = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OwnedShardInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard_id = 1; */
        if (message.shardId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shardId);
        /* int64 total_jobs = 2; */
        if (message.totalJobs !== 0n)
            writer.tag(2, WireType.Varint).int64(message.totalJobs);
        /* int64 completed_jobs = 3; */
        if (message.completedJobs !== 0n)
            writer.tag(3, WireType.Varint).int64(message.completedJobs);
        /* string cleanup_status = 4; */
        if (message.cleanupStatus !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cleanupStatus);
        /* int64 created_at_ms = 5; */
        if (message.createdAtMs !== 0n)
            writer.tag(5, WireType.Varint).int64(message.createdAtMs);
        /* int64 cleanup_completed_at_ms = 6; */
        if (message.cleanupCompletedAtMs !== 0n)
            writer.tag(6, WireType.Varint).int64(message.cleanupCompletedAtMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.OwnedShardInfo
 */
export const OwnedShardInfo = new OwnedShardInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetNodeInfoRequest$Type extends MessageType<GetNodeInfoRequest> {
    constructor() {
        super("silo.v1.GetNodeInfoRequest", []);
    }
    create(value?: PartialMessage<GetNodeInfoRequest>): GetNodeInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetNodeInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetNodeInfoRequest): GetNodeInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetNodeInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetNodeInfoRequest
 */
export const GetNodeInfoRequest = new GetNodeInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetNodeInfoResponse$Type extends MessageType<GetNodeInfoResponse> {
    constructor() {
        super("silo.v1.GetNodeInfoResponse", [
            { no: 1, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owned_shards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OwnedShardInfo },
            { no: 3, name: "placement_rings", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetNodeInfoResponse>): GetNodeInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nodeId = "";
        message.ownedShards = [];
        message.placementRings = [];
        if (value !== undefined)
            reflectionMergePartial<GetNodeInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetNodeInfoResponse): GetNodeInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string node_id */ 1:
                    message.nodeId = reader.string();
                    break;
                case /* repeated silo.v1.OwnedShardInfo owned_shards */ 2:
                    message.ownedShards.push(OwnedShardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string placement_rings */ 3:
                    message.placementRings.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetNodeInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string node_id = 1; */
        if (message.nodeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
        /* repeated silo.v1.OwnedShardInfo owned_shards = 2; */
        for (let i = 0; i < message.ownedShards.length; i++)
            OwnedShardInfo.internalBinaryWrite(message.ownedShards[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string placement_rings = 3; */
        for (let i = 0; i < message.placementRings.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.placementRings[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.GetNodeInfoResponse
 */
export const GetNodeInfoResponse = new GetNodeInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigureShardRequest$Type extends MessageType<ConfigureShardRequest> {
    constructor() {
        super("silo.v1.ConfigureShardRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "placement_ring", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 100, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConfigureShardRequest>): ConfigureShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<ConfigureShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigureShardRequest): ConfigureShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* optional string placement_ring */ 2:
                    message.placementRing = reader.string();
                    break;
                case /* optional string tenant */ 100:
                    message.tenant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigureShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* optional string placement_ring = 2; */
        if (message.placementRing !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.placementRing);
        /* optional string tenant = 100; */
        if (message.tenant !== undefined)
            writer.tag(100, WireType.LengthDelimited).string(message.tenant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ConfigureShardRequest
 */
export const ConfigureShardRequest = new ConfigureShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigureShardResponse$Type extends MessageType<ConfigureShardResponse> {
    constructor() {
        super("silo.v1.ConfigureShardResponse", [
            { no: 1, name: "previous_ring", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "current_ring", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConfigureShardResponse>): ConfigureShardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.previousRing = "";
        message.currentRing = "";
        if (value !== undefined)
            reflectionMergePartial<ConfigureShardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigureShardResponse): ConfigureShardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string previous_ring */ 1:
                    message.previousRing = reader.string();
                    break;
                case /* string current_ring */ 2:
                    message.currentRing = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigureShardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string previous_ring = 1; */
        if (message.previousRing !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.previousRing);
        /* string current_ring = 2; */
        if (message.currentRing !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.currentRing);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ConfigureShardResponse
 */
export const ConfigureShardResponse = new ConfigureShardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportAttempt$Type extends MessageType<ImportAttempt> {
    constructor() {
        super("silo.v1.ImportAttempt", [
            { no: 1, name: "status", kind: "enum", T: () => ["silo.v1.AttemptStatus", AttemptStatus, "ATTEMPT_STATUS_"] },
            { no: 2, name: "started_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "finished_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "result", kind: "message", T: () => SerializedBytes },
            { no: 5, name: "error_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "error_data", kind: "message", T: () => SerializedBytes }
        ]);
    }
    create(value?: PartialMessage<ImportAttempt>): ImportAttempt {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.startedAtMs = 0n;
        message.finishedAtMs = 0n;
        if (value !== undefined)
            reflectionMergePartial<ImportAttempt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportAttempt): ImportAttempt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* silo.v1.AttemptStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* int64 started_at_ms */ 2:
                    message.startedAtMs = reader.int64().toBigInt();
                    break;
                case /* int64 finished_at_ms */ 3:
                    message.finishedAtMs = reader.int64().toBigInt();
                    break;
                case /* optional silo.v1.SerializedBytes result */ 4:
                    message.result = SerializedBytes.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* optional string error_code */ 5:
                    message.errorCode = reader.string();
                    break;
                case /* optional silo.v1.SerializedBytes error_data */ 6:
                    message.errorData = SerializedBytes.internalBinaryRead(reader, reader.uint32(), options, message.errorData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportAttempt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* silo.v1.AttemptStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* int64 started_at_ms = 2; */
        if (message.startedAtMs !== 0n)
            writer.tag(2, WireType.Varint).int64(message.startedAtMs);
        /* int64 finished_at_ms = 3; */
        if (message.finishedAtMs !== 0n)
            writer.tag(3, WireType.Varint).int64(message.finishedAtMs);
        /* optional silo.v1.SerializedBytes result = 4; */
        if (message.result)
            SerializedBytes.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional string error_code = 5; */
        if (message.errorCode !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.errorCode);
        /* optional silo.v1.SerializedBytes error_data = 6; */
        if (message.errorData)
            SerializedBytes.internalBinaryWrite(message.errorData, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ImportAttempt
 */
export const ImportAttempt = new ImportAttempt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportJobRequest$Type extends MessageType<ImportJobRequest> {
    constructor() {
        super("silo.v1.ImportJobRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "priority", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "enqueue_time_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "start_at_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "retry_policy", kind: "message", T: () => RetryPolicy },
            { no: 7, name: "payload", kind: "message", T: () => SerializedBytes },
            { no: 8, name: "limits", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Limit },
            { no: 9, name: "tenant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 11, name: "task_group", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "attempts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ImportAttempt }
        ]);
    }
    create(value?: PartialMessage<ImportJobRequest>): ImportJobRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        message.id = "";
        message.priority = 0;
        message.enqueueTimeMs = 0n;
        message.startAtMs = 0n;
        message.limits = [];
        message.metadata = {};
        message.taskGroup = "";
        message.attempts = [];
        if (value !== undefined)
            reflectionMergePartial<ImportJobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportJobRequest): ImportJobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* uint32 priority */ 3:
                    message.priority = reader.uint32();
                    break;
                case /* int64 enqueue_time_ms */ 4:
                    message.enqueueTimeMs = reader.int64().toBigInt();
                    break;
                case /* int64 start_at_ms */ 5:
                    message.startAtMs = reader.int64().toBigInt();
                    break;
                case /* optional silo.v1.RetryPolicy retry_policy */ 6:
                    message.retryPolicy = RetryPolicy.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicy);
                    break;
                case /* silo.v1.SerializedBytes payload */ 7:
                    message.payload = SerializedBytes.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                case /* repeated silo.v1.Limit limits */ 8:
                    message.limits.push(Limit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string tenant */ 9:
                    message.tenant = reader.string();
                    break;
                case /* map<string, string> metadata */ 10:
                    this.binaryReadMap10(message.metadata, reader, options);
                    break;
                case /* string task_group */ 11:
                    message.taskGroup = reader.string();
                    break;
                case /* repeated silo.v1.ImportAttempt attempts */ 12:
                    message.attempts.push(ImportAttempt.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: ImportJobRequest["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ImportJobRequest["metadata"] | undefined, val: ImportJobRequest["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for silo.v1.ImportJobRequest.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ImportJobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* uint32 priority = 3; */
        if (message.priority !== 0)
            writer.tag(3, WireType.Varint).uint32(message.priority);
        /* int64 enqueue_time_ms = 4; */
        if (message.enqueueTimeMs !== 0n)
            writer.tag(4, WireType.Varint).int64(message.enqueueTimeMs);
        /* int64 start_at_ms = 5; */
        if (message.startAtMs !== 0n)
            writer.tag(5, WireType.Varint).int64(message.startAtMs);
        /* optional silo.v1.RetryPolicy retry_policy = 6; */
        if (message.retryPolicy)
            RetryPolicy.internalBinaryWrite(message.retryPolicy, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* silo.v1.SerializedBytes payload = 7; */
        if (message.payload)
            SerializedBytes.internalBinaryWrite(message.payload, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated silo.v1.Limit limits = 8; */
        for (let i = 0; i < message.limits.length; i++)
            Limit.internalBinaryWrite(message.limits[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional string tenant = 9; */
        if (message.tenant !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.tenant);
        /* map<string, string> metadata = 10; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        /* string task_group = 11; */
        if (message.taskGroup !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.taskGroup);
        /* repeated silo.v1.ImportAttempt attempts = 12; */
        for (let i = 0; i < message.attempts.length; i++)
            ImportAttempt.internalBinaryWrite(message.attempts[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ImportJobRequest
 */
export const ImportJobRequest = new ImportJobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportJobsRequest$Type extends MessageType<ImportJobsRequest> {
    constructor() {
        super("silo.v1.ImportJobsRequest", [
            { no: 1, name: "jobs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ImportJobRequest }
        ]);
    }
    create(value?: PartialMessage<ImportJobsRequest>): ImportJobsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobs = [];
        if (value !== undefined)
            reflectionMergePartial<ImportJobsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportJobsRequest): ImportJobsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated silo.v1.ImportJobRequest jobs */ 1:
                    message.jobs.push(ImportJobRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportJobsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated silo.v1.ImportJobRequest jobs = 1; */
        for (let i = 0; i < message.jobs.length; i++)
            ImportJobRequest.internalBinaryWrite(message.jobs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ImportJobsRequest
 */
export const ImportJobsRequest = new ImportJobsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportJobResult$Type extends MessageType<ImportJobResult> {
    constructor() {
        super("silo.v1.ImportJobResult", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "status", kind: "enum", T: () => ["silo.v1.JobStatus", JobStatus, "JOB_STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<ImportJobResult>): ImportJobResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.success = false;
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<ImportJobResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportJobResult): ImportJobResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* bool success */ 2:
                    message.success = reader.bool();
                    break;
                case /* optional string error */ 3:
                    message.error = reader.string();
                    break;
                case /* silo.v1.JobStatus status */ 4:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportJobResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* bool success = 2; */
        if (message.success !== false)
            writer.tag(2, WireType.Varint).bool(message.success);
        /* optional string error = 3; */
        if (message.error !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.error);
        /* silo.v1.JobStatus status = 4; */
        if (message.status !== 0)
            writer.tag(4, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ImportJobResult
 */
export const ImportJobResult = new ImportJobResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportJobsResponse$Type extends MessageType<ImportJobsResponse> {
    constructor() {
        super("silo.v1.ImportJobsResponse", [
            { no: 1, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ImportJobResult }
        ]);
    }
    create(value?: PartialMessage<ImportJobsResponse>): ImportJobsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<ImportJobsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportJobsResponse): ImportJobsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated silo.v1.ImportJobResult results */ 1:
                    message.results.push(ImportJobResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportJobsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated silo.v1.ImportJobResult results = 1; */
        for (let i = 0; i < message.results.length; i++)
            ImportJobResult.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ImportJobsResponse
 */
export const ImportJobsResponse = new ImportJobsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForceReleaseShardRequest$Type extends MessageType<ForceReleaseShardRequest> {
    constructor() {
        super("silo.v1.ForceReleaseShardRequest", [
            { no: 1, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ForceReleaseShardRequest>): ForceReleaseShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<ForceReleaseShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForceReleaseShardRequest): ForceReleaseShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string shard */ 1:
                    message.shard = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForceReleaseShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string shard = 1; */
        if (message.shard !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.shard);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ForceReleaseShardRequest
 */
export const ForceReleaseShardRequest = new ForceReleaseShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForceReleaseShardResponse$Type extends MessageType<ForceReleaseShardResponse> {
    constructor() {
        super("silo.v1.ForceReleaseShardResponse", [
            { no: 1, name: "released", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ForceReleaseShardResponse>): ForceReleaseShardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.released = false;
        if (value !== undefined)
            reflectionMergePartial<ForceReleaseShardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForceReleaseShardResponse): ForceReleaseShardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool released */ 1:
                    message.released = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForceReleaseShardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool released = 1; */
        if (message.released !== false)
            writer.tag(1, WireType.Varint).bool(message.released);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message silo.v1.ForceReleaseShardResponse
 */
export const ForceReleaseShardResponse = new ForceReleaseShardResponse$Type();
/**
 * @generated ServiceType for protobuf service silo.v1.Silo
 */
export const Silo = new ServiceType("silo.v1.Silo", [
    { name: "GetClusterInfo", options: {}, I: GetClusterInfoRequest, O: GetClusterInfoResponse },
    { name: "GetNodeInfo", options: {}, I: GetNodeInfoRequest, O: GetNodeInfoResponse },
    { name: "Enqueue", options: {}, I: EnqueueRequest, O: EnqueueResponse },
    { name: "GetJob", options: {}, I: GetJobRequest, O: GetJobResponse },
    { name: "GetJobResult", options: {}, I: GetJobResultRequest, O: GetJobResultResponse },
    { name: "DeleteJob", options: {}, I: DeleteJobRequest, O: DeleteJobResponse },
    { name: "CancelJob", options: {}, I: CancelJobRequest, O: CancelJobResponse },
    { name: "RestartJob", options: {}, I: RestartJobRequest, O: RestartJobResponse },
    { name: "ExpediteJob", options: {}, I: ExpediteJobRequest, O: ExpediteJobResponse },
    { name: "LeaseTask", options: {}, I: LeaseTaskRequest, O: LeaseTaskResponse },
    { name: "LeaseTasks", options: {}, I: LeaseTasksRequest, O: LeaseTasksResponse },
    { name: "ReportOutcome", options: {}, I: ReportOutcomeRequest, O: ReportOutcomeResponse },
    { name: "ReportRefreshOutcome", options: {}, I: ReportRefreshOutcomeRequest, O: ReportRefreshOutcomeResponse },
    { name: "Heartbeat", options: {}, I: HeartbeatRequest, O: HeartbeatResponse },
    { name: "Query", options: {}, I: QueryRequest, O: QueryResponse },
    { name: "QueryArrow", serverStreaming: true, options: {}, I: QueryArrowRequest, O: ArrowIpcMessage },
    { name: "CpuProfile", options: {}, I: CpuProfileRequest, O: CpuProfileResponse },
    { name: "RequestSplit", options: {}, I: RequestSplitRequest, O: RequestSplitResponse },
    { name: "GetSplitStatus", options: {}, I: GetSplitStatusRequest, O: GetSplitStatusResponse },
    { name: "ConfigureShard", options: {}, I: ConfigureShardRequest, O: ConfigureShardResponse },
    { name: "ImportJobs", options: {}, I: ImportJobsRequest, O: ImportJobsResponse },
    { name: "ResetShards", options: {}, I: ResetShardsRequest, O: ResetShardsResponse },
    { name: "ForceReleaseShard", options: {}, I: ForceReleaseShardRequest, O: ForceReleaseShardResponse }
]);
