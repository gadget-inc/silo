# Silo

A background job queueing system built on top of object storage via [slatedb](https://slatedb.io)

# Architecture Overview

Key components:

- `src/server.rs` - Main gRPC server, routes requests to appropriate shards
- `src/job_store_shard/` - Core job storage logic (enqueue, dequeue, cancel, retry, etc.)
- `src/coordination/` - Pluggable cluster coordination backends:
  - `etcd.rs` - Etcd-based distributed coordination
  - `k8s.rs` - Kubernetes Lease/ConfigMap-based coordination
  - `none.rs` - Single-node mode (dev)
- `src/concurrency.rs` - Concurrency limit tracking with holder-based grants
- `src/query.rs` - DataFusion-based query engine for single shards
- `src/cluster_query.rs` - Distributed query execution across nodes
- `src/cluster_client.rs` - Client for connecting to remote silo nodes
- `src/webui.rs` - Web UI for cluster inspection
- `src/keys.rs` - Storage key encoding
- `proto/silo.proto` - gRPC service and message definitions
- `specs/` - Alloy formal models for correctness verification
- `tests/` - all Rust tests including DST tests
- `typescript_client/` - TypeScript client library

# Docs

Some parts of silo's behaviour are documented in the `docs/` package. The docs can sometimes fall out of date -- if you find conflicting information between the implementation and the docs, consider the implementation the source of truth. Let the user know and ask if the docs should be updated.

# Nix

The silo repo uses nix, nix flakes and direnv to manage the development environment. If you are finding that commands are missing from your development environment, reload the shell with `direnv reload`.

Don't use `nix develop -c` to run commands as it doesnt pass signals down correctly -- assume direnv has properly setup your shell, and reload if it hasn't.

Use `direnv exec` to run one-off commands in new shells to activate the nix env, which should have all the development tooling necessary, like `protoc` or similar.

# Configuration

Example configs are in `example_configs/`. The server reads TOML config files. SlateDB settings can be partially specified and defaults will fill in the rest.

# Protocol Buffers

Proto definitions are in `proto/silo.proto`. Rust code is generated by `build.rs` during cargo build. If you modify the proto file, just run `cargo build` - no separate protoc step needed.

# Rust Style

- Do NOT use unwraps or anything that can panic in Rust code, instead, handle errors. In tests, unwraps and panics are fine!
- In Rust code I prefer using `crate::` to `super::`; please don't use `super::`. If you see a lingering `super::` from someone else clean it up.
- Avoid `pub use` on imports unless you are re-exposing a dependency so downstream consumers do not have to depend on it directly.
- Skip global state via `lazy_static!`, `Once`, or similar; prefer passing explicit context structs for any shared state. If existing code is already doing this, don't change it.
- Prefer strong types over strings, use enums and newtypes when the domain is closed or needs validation.
- Put Rust tests in files within the `tests/` folder. Don't put tests inline within files in the `src/` folder.
- Use typed errors with thiserror (e.g., `JobStoreShardError`, `ClusterClientError`). Propagate errors with `?` rather than matching and re-wrapping unnecessarily.

# Formatting

You can format all the rust code in the project with:

```shell
just fmt
```

# Tests

When running tests, assume the background services required are already running.

You can run rust tests with `cargo test`. Some cargo tests have special requirements:

- the k8s coordination tests must run single-threaded: `cargo test k8s_ -- --test-threads=1`
- the etcd coordination tests are flaky when run in parallel; CI runs them in a separate runner in serial
- the turmoil DST tests which you don't need to run unless told to

You can run TypeScript client tests with

```shell
cd typescript_client
pnpm test
```

You can run the TypeScript integration tests with:

```shell
cd typescript_client
RUN_INTEGRATION=true pnpm test
```

The TypeScript integration tests require a running Silo server. Assume one is running. Don't run `dev` or `process-compose` yourself unless you are a cloud agent.

Use the #[silo::test] macro for wrapping rust test cases (not tokio::test).

Run tests as often as you like. When running tests, don't run them within the sandbox with limited permissions -- it often causes false positives with failed network accesses or SSL issues.

## Test Flake Notes

Common causes of test flakes to be aware of:

- Etcd lease timing issues - tests should use adequate timeouts for lease operations
- K8s coordination tests interfere with each other - must run single-threaded
- DST tests: slatedb compactor is disabled to avoid non-determinism
- Use separate tenants in tests to avoid cross-test interference

# Deterministic Simulation Tests

We use turmoil and mad-turmoil for DST tests. See CONTRIBUTING.md for more details.

# Kubernetes Tests

Assume the developer has a k8s cluster running locally in orbstack which can be used for executing k8s tests.

# Debugging

Control log levels with `RUST_LOG`:

```shell
RUST_LOG=debug cargo test ...
RUST_LOG=silo::coordination=trace cargo test ...
```

# Local Development (Cloud Agents Only)

If you're a cloud agent that needs to start background services:

- `dev` or `process-compose up` starts etcd, gubernator, and two silo nodes with auto-reload
- `just etcd` starts just etcd for simpler setups

# Alloy Sigils

We use text-based sigils to ensure that the invariants and assertions in the Alloy model have clear corresponding Rust code that enforces them. They look like `SILO-SOMETHING-123`.

CI validates that all the sigils in the Alloy model are present in the Rust implementation. If changing the Alloy model to add new key invariants or assertions, complete your work on the Alloy model, then ensure you update the Rust code to make sure the sigils match. If the change to the Alloy model is large, ask if we should do the Rust work first, but if it is small, don't ask and just update the Rust code right away.

Don't invent new sigils in the Rust code that don't have corresponding assertions in the Alloy models.
