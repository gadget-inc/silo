# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

# Silo

A background job queueing system built on top of object storage via [slatedb](https://slatedb.io). It's a durable, horizontally-scalable job broker that communicates with workers via gRPC.

# Architecture Overview

## Request Flow

gRPC requests arrive at `src/server.rs`, which hashes the tenant ID to determine the owning shard. If the shard is local, the request is handled by a `JobStoreShard`; if remote, the server returns a redirect with the owner's address (clients retry via `ClusterClient`).

## Sharding Model

Tenants are assigned to shards via range-based partitioning (`src/shard_range.rs`). Each shard has a UUID identity (`ShardId`) and owns a lexicographic range of tenant IDs. Shard ownership is coordinated across nodes using rendezvous hashing (`src/coordination/mod.rs`). Shards can be split dynamically via `src/coordination/split.rs`.

## Storage

Each shard is backed by a SlateDB instance (an LSM on object storage). Keys are binary-encoded using `storekey` for lexicographic ordering (`src/keys.rs`). Key prefixes: `0x01` job info, `0x02` job status, `0x03` status/time index, `0x04` metadata index, `0x05` tasks (execution queue), `0x06` leases, `0x07` attempts, `0x08`/`0x09` concurrency requests/holders, `0x0A` cancelled, `0x0B` floating limits, `0xF0+` counters/cleanup.

## Shard Lifecycle

`ShardFactory` (`src/factory.rs`) manages opening/closing SlateDB instances as shard ownership changes. The coordinator signals the factory when shards are gained or lost. `TaskBroker` within each shard handles dequeue scheduling with long-poll notification.

## Key Components

- `src/server.rs` - gRPC server, routes to shards, handles redirects
- `src/job_store_shard/` - Core storage operations (enqueue, dequeue, cancel, retry, expedite, etc.)
- `src/coordination/` - Cluster coordination backends (etcd, k8s, none)
- `src/factory.rs` - Opens/closes SlateDB shard instances per ownership
- `src/concurrency.rs` - Concurrency limit tracking with holder-based grants
- `src/task_broker.rs` - Dequeue scheduling with long-poll notification
- `src/query.rs` / `src/cluster_query.rs` - DataFusion-based query engine (single shard / cross-cluster)
- `src/cluster_client.rs` - Client for connecting to remote silo nodes
- `src/keys.rs` - Binary key encoding (storekey)
- `src/shard_range.rs` - Range-based shard identity and tenant routing
- `src/gubernator.rs` - Rate limiting client (talks to gubernator)
- `proto/silo.proto` - gRPC service and message definitions
- `specs/` - Alloy formal models for correctness verification
- `tests/` - All Rust tests including DST tests
- `typescript_client/` - TypeScript client library

# Docs

Some parts of silo's behaviour are documented in the `docs/` package. The docs can sometimes fall out of date -- if you find conflicting information between the implementation and the docs, consider the implementation the source of truth. Let the user know and ask if the docs should be updated.

# Nix

The silo repo uses nix, nix flakes and direnv to manage the development environment. If you are finding that commands are missing from your development environment, reload the shell with `direnv reload`.

Don't use `nix develop -c` to run commands as it doesnt pass signals down correctly -- assume direnv has properly setup your shell, and reload if it hasn't.

Use `direnv exec` to run one-off commands in new shells to activate the nix env, which should have all the development tooling necessary, like `protoc` or similar.

# Configuration

Example configs are in `example_configs/`. The server reads TOML config files. SlateDB settings can be partially specified and defaults will fill in the rest.

# Protocol Buffers

Proto definitions are in `proto/silo.proto` and `proto/gubernator.proto`. Rust code is generated by `build.rs` during cargo build. If you modify proto files, just run `cargo build` - no separate protoc step needed.

# Rust Style

- Do NOT use unwraps or anything that can panic in Rust code, instead, handle errors. In tests, unwraps and panics are fine!
- In Rust code I prefer using `crate::` to `super::`; please don't use `super::`. If you see a lingering `super::` from someone else clean it up.
- Avoid `pub use` on imports unless you are re-exposing a dependency so downstream consumers do not have to depend on it directly.
- Skip global state via `lazy_static!`, `Once`, or similar; prefer passing explicit context structs for any shared state. If existing code is already doing this, don't change it.
- Prefer strong types over strings, use enums and newtypes when the domain is closed or needs validation.
- Put Rust tests in files within the `tests/` folder. Don't put tests inline within files in the `src/` folder.
- Use typed errors with thiserror (e.g., `JobStoreShardError`, `ClusterClientError`). Propagate errors with `?` rather than matching and re-wrapping unnecessarily.

# Formatting and Linting

```shell
just fmt          # runs clippy --fix then rustfmt
cargo clippy      # lint check only
```

# Tests

When running tests, assume the background services required are already running.

```shell
cargo test                                    # all tests (skipping k8s/etcd/DST)
cargo test -- --skip k8s_ --skip etcd_ --skip coordination_split_tests  # what CI runs in the main test job
cargo test some_test_name                     # run a single test by name
cargo test --test job_store_shard_enqueue_tests  # run a single test file
```

Special test groups that must run single-threaded:

```shell
cargo test --test etcd_coordination_tests -- --test-threads=1
cargo test --test coordination_split_tests -- --test-threads=1
cargo test --test k8s_coordination_tests -- --test-threads=1
```

The turmoil DST tests don't need to be run unless told to. See CONTRIBUTING.md for DST details.

Use the `#[silo::test]` macro for wrapping rust test cases (not `tokio::test`). It sets up tracing and optional Perfetto trace capture.

Run tests as often as you like. When running tests, don't run them within the sandbox with limited permissions -- it often causes false positives with failed network accesses or SSL issues.

## TypeScript Client Tests

```shell
cd typescript_client
pnpm test                        # unit tests (no server needed)
RUN_INTEGRATION=true pnpm test   # integration tests (requires running silo server)
```

The TypeScript integration tests require a running Silo server. Assume one is running. Don't run `dev` or `process-compose` yourself unless you are a cloud agent.

Use the #[silo::test] macro for wrapping rust test cases (not tokio::test).

Run tests as often as you like. When running tests, don't run them within the sandbox with limited permissions -- it often causes false positives with failed network accesses or SSL issues.

## Test Flake Notes

Common causes of test flakes to be aware of:

- Etcd lease timing issues - tests should use adequate timeouts for lease operations
- K8s coordination tests interfere with each other - must run single-threaded
- DST tests: slatedb compactor is disabled to avoid non-determinism
- Use separate tenants in tests to avoid cross-test interference

# Deterministic Simulation Tests

We use turmoil and mad-turmoil for DST tests. See CONTRIBUTING.md for more details on how to run DST tests, both to verify the determinism or reproduce a failure for a given seed.

# Coordination Backends

The k8s and etcd coordinators have parallel implementations of `reconcile_shards`. Bug fixes to one should be checked against the other. The `ShardGuardState` state machine and `CoordinatorBase` shared helpers in `src/coordination/mod.rs` are used by both.

# Kubernetes Tests

Assume the developer has a k8s cluster running locally in orbstack which can be used for executing k8s tests.

# Debugging

Control log levels with `RUST_LOG`:

```shell
RUST_LOG=debug cargo test ...
RUST_LOG=silo::coordination=trace cargo test ...
```

Write debug logs to file with `SILO_DEBUG_LOG_FILE=test-debug.log cargo test ...`.

# Local Development (Cloud Agents Only)

If you're a cloud agent that needs to start background services:

- `dev` or `process-compose up` starts etcd, gubernator, and two silo nodes with auto-reload
- `just etcd` starts just etcd for simpler setups

# Alloy Sigils

We use text-based sigils to ensure that the invariants and assertions in the Alloy model have clear corresponding Rust code that enforces them. They look like `SILO-SOMETHING-123`.

CI validates that all the sigils in the Alloy model are present in the Rust implementation. If changing the Alloy model to add new key invariants or assertions, complete your work on the Alloy model, then ensure you update the Rust code to make sure the sigils match. If the change to the Alloy model is large, ask if we should do the Rust work first, but if it is small, don't ask and just update the Rust code right away.

Don't invent new sigils in the Rust code that don't have corresponding assertions in the Alloy models.
